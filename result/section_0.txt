이 강의에서는 OCI 모델, 즉 개방형 시스템 상호연결 모델에 대해 말씀드리겠습니다.

그리고 저는 20년 전, 제가 대학에 다닐 때를 기억합니다.

강사님께서 OSI 모델을 설명하셨지만 저는 정말 아무것도 이해하지 못했습니다.

그리고 저는 그것이 중요하다고 생각하지 않았습니다. 왜냐하면 저는 C 코드와 C++를 작성하는 것에 흥분했기 때문입니다.

암호.

저는 인터페이스를 만들고 싶습니다.

저는 Visual Basic 애플리케이션을 만들고 싶습니다.

알다시피, 저는 그런 것에 관심이 있었고, 그것이 무엇을 의미하는지 정말 이해하지 못했습니다.

설명했죠?

그래서 결국 모든 것을 암기하게 되고, 그것은 마치 시험에 합격하는 것과 같습니다.

하지만 불행히도 아무것도 얻지 못했어요. 의사 선생님이 정말 훌륭했지만요.

안타깝게도.

그래서 저는 정말 후회합니다.

하지만 제가 하고 싶었던 것은 그 경험으로부터 배우는 것이었습니다.

제가 모델링한 모든 것은 그것을 이해하는 데 정말 중요합니다.

엔지니어, 소프트웨어 엔지니어라면 누구나 네트워킹을 통해 상호 작용하고 싶어할 것입니다.

OSI 모델을 이해하는 방법은 알 수도 있고 모를 수도 있습니다.

모든 것을 이해해야 한다고 생각하지 말고, 7개 계층만 효과적으로 이해하면 됩니다.

그리고 우리는 또한 단순화된 OCI 모델에 대해서도 이야기할 것입니다. 왜냐하면 이 모델에는 비판이 있기 때문입니다.

알다시피, 그런 것에 관해서는요.

하지만 호주 모델만 놓고 보면 이 7개 계층이 어디에 적용되나요?

그것이 정말 중요한 것입니다.

귀하의 지원서는 어디에 있나요?

당신은 "상관없다"고 말할 수도 있을 겁니다.

앱이 어디에 있는지 왜 신경 써야 하나요?

아니, 그래야 해요.

앱이 다른 두 앱 간의 브리지인 경우 실제로 무엇을 찾고 있는지 이해해야 합니다.

에.

무엇이 보이나요?

Mac 주소를 보고 계신가요? 아니면 IP 패키지를 보고 계신가요? 아니면 이미 세그먼트를 보고 계신가요?

아니면 항구를 살펴보는 거야?

TCP 옵션을 살펴보고 있습니다.

아니면 연결 콘솔, TCP 연결 자체를 보고 있습니까? 아니면 디코딩하고 있습니까?

아니면 JSON으로 도착하는 것을 인코딩하거나 직렬화합니까?

내 자료를 해독해서 볼 건가요?

그리고 모든 단일 계층에는 의미가 있으며, 모든 애플리케이션에는 cDNA 역방향 프록시, 로드 밸런서가 있습니다.

역방향 프록시의 경우 API 게이트웨이는 이러한 계층 중 하나 이상에 존재해야 합니다.

제가 이야기하고 싶었던 것은 바로 이것입니다.

그럼, 슬라이드로 넘어가서 자세히 설명하겠습니다.

정말 재미있을 거라고 약속해요.

괜찮은.

이 슬라이드는 조금 복잡하기 때문에 저는 곧 사라질 텐데, 멈추세요.

그러니 내가 여기 있을게요.

나는 여기에 있을거야.

나는 단지 장면 뒤에 있는 개념을 설명할 것이고 이것을 요약하기 위해 마지막에 나타날 것입니다.

물건.

괜찮은.

저는 이를 개방형 시스템 상호연결 모델이라고 부릅니다.

아시다시피, 개방적인 시스템은 개방적이어야 하며 개방적인 의사소통이 정말 필요하기 때문입니다.

우리는 이 문제를 이해하고 이를 표준으로 만들어야 합니다.

그래서.

Orci 모델, 시작해 볼까요?

왜 커뮤니케이션 모델이 필요한가?

나는 항상, 당신도 알다시피, 나는 항상 Y로 시작합니다. 왜냐하면 나는 무언가를 이해하고 싶지 않기 때문입니다.

적어도 개인적으로는 그것이 존재하는 이유를 모르겠습니다.

그렇죠. 그래서 여기 목표는 독립적인 애플리케이션을 만드는 거예요.

그러니까, 이런 걸 상상해보세요.

실제로 표준이 없다면 네트워킹 애플리케이션을 구축해야 합니다.

그러면 제 서버가 클라이언트와 통신하는 방법을 모르기 때문에 이 작업을 할 수 없습니다.

안녕하세요?

아시죠, 디지털에서 아날로그로, 아날로그에서 디지털로 비트를 어떻게 전치하시나요?

이 부분을 어떻게 보아야 하나요?

아시죠, 기준이 있어야죠.

꼭 눈부실 필요는 없습니다.

이런 것들을 애플리케이션 수준에서 이해할 수 있도록 잘라내는 방법을 이해할 수 있는 프로토콜이 있나요?

표준이 없으면 애플리케이션은 기본 네트워크 매체에 대한 지식을 갖고 있어야 합니다.

더 나쁜.

이런 상황을 상상해보세요.

Wi-Fi에서 작동하도록 앱의 여러 버전을 주문해야 한다고 상상해보세요.

이더넷에서 작업하려면 다른 버전이 필요합니다.

LTE에서 작동하려면 다른 로직이 필요하고, 광섬유에서 작동하려면 다른 버전이 필요합니다.

그것은 재앙이 될 것이다.

그렇죠. 오늘날 우리는 그것을 당연하게 여깁니다.

우리는 그것을 당연하게 여깁니다.

잠깐 등장할게요.

우리는 이 일을 정말 당연하게 여깁니다.

오늘 Node.js 애플리케이션을 빌드하고 요청을 보내거나 수신만 하고 있습니다.

이 애플리케이션이 어디에서 실행되든 상관없이 어떤 CPU에서든 실행됩니다. 누군가가 똑똑하게 만들었기 때문입니다.

그래서 모든 CPU에서 컴파일됩니다.

그리고 요청을 보낼 때 위성을 통해 보내든, 아니면

라디오 와이파이를 통해 전송하거나 이더넷 전기 신호를 통해 전송하거나 LTE를 통해 전송합니다.

전파나 광섬유를 통해 생각하는 것.

이유는 중요하지 않습니다. 우리가 표준을 만들었고 그 표준이 전 세계적으로 효과적으로 사용되고 있기 때문입니다.

알잖아.

그리고 병동 전체.

와드와 글로벌의 차이점은 무엇인가요?

글로벌은 지구를 뜻하는 건가요 아니면 우주로 가는 건가요?

나는 그것이 우주로 가는 것이라고 믿는다.

전 세계가 소통할 수 있는 글로벌 개방형 시스템입니다.

그것을 이해하는 것만으로도 정말 강력합니다. 다른 애플리케이션을 빌드해야 한다고 상상해 보세요.

빛에 관해 작업하는 건 어떨까요? 모두 다른 매체이니까요, 맞죠?

그럼, 어떻게 응용 프로그램이 똑같을 것이라고 기대할 수 있겠어요?

기준이 있어야 합니다.

그렇지 않으면 응용 프로그램은 '아, 이 섬유에 말하고 있구나'입니다.

이렇게 하면 비트를 광신호로 변환할 수 있습니다.

아니면 이게 라디오파라면, 라디오를 하려면 이렇게 해야죠.

하지만 이것이 너무 당연하게 여겨지기 때문에 설명하고 싶었습니다.

하지만 사람들, 똑똑한 사람들이 우리가 이런 것에 대해 걱정할 필요가 없도록 이것을 만들었습니다.

슬라이드로 돌아가자.

네트워크 장비 관리.

표준 모형이 없다면 말이죠.

정적 모델이 없으면 네트워크 장비를 업그레이드하는 것이 매우 어렵습니다.

이제 알았죠.

모든 장비의 기준이 다르다면 더 이상 발전할 수 없습니다.

아시다시피, 서로 통신하는 다양한 모델과 다양한 것들이 있을 겁니다.

우선, 그들은 서로 소통을 할 수 없을 것입니다.

이 라우터는 표준이 없기 때문에 이 라우터와 통신할 수 없습니다.

오른쪽.

그리고 여기서 아름다운 점은 다음과 같습니다.

언더라이닝 매체에 상관없이 실제 네트워크는 완전히 분리되어 있기 때문에 업그레이드가 가능합니다.

실제 매체 그 자체로부터.

그럼 우리가 정말 걱정할 게 아무것도 없잖아요.

밑줄을 긋는 매체.

그냥 정상적으로 장비를 업그레이드 하시면 되고, 뭐 가져오시든 우리가 지원해 드리겠습니다.

알다시피, 우리가 그것에 대해 말하는 방법을 알고 있다면, 혁신을 분리하는 방법을 알고 있다면, 그게 바로 그것입니다.

우리가 잠깐 이야기한 내용은 다음과 같습니다.

나머지 모듈에 영향을 주지 않고 각 계층에서 별도로 혁신을 수행할 수 있습니다.

응.

그리고 그것이 매우 매우 중요하다는 것입니다.

잠시 후에 계층에 대해 이야기해 보겠습니다.

하지만 각 계층이 이런 방식으로 구축된 이유는 각 계층마다 혁신하고 개선할 수 있기 때문입니다.

아시다시피, 지금은 조금 모호하지만 곧 명확해질 겁니다.

아시다시피, 물리적 계층은 매체이자 라디오이기 때문에 개선할 수 있습니다.

만약 누군가 광섬유보다 빠른 것을 발명했다면, 당신은 할 수 없을 거라고 생각해요.

빛보다 빠른 것은 없지만, 내 말은 알겠죠.

네, 더 효율적이죠.

그러면 우리는 그에 맞는 인터페이스를 구축하고 지원하게 될 거예요. 알겠죠?

오른쪽.

그리고 두 번째 계층은 아무 관련이 없습니다.

그것은 단지 두 번째 계층이 비트를 전달하고 변환이 물리적 계층에서 일어날 것입니다.

아시다시피, 세 번째 계층, 즉 IP 계층은 이런 것들을 처리합니다.

더 많은 콘텐츠나 헤더를 추가하고 싶다면 레이어 레이어에도 추가할 수 있습니다.

아시다시피, 이렇게 하면 결국 다른 것도 망가질 수 있겠지만요.

하지만 그건 또 다른 주제입니다.

알다시피, 프로토콜이라는 것이 있기 때문에 헤더만 늘릴 수 있습니다.

골화는 이러한 모든 프로토콜, 중간에 있는 이러한 모든 라우터가 실제로 어떻게 이해하는지입니다.

어떤 방식으로 사물을 읽는다.

그리고 만약 이것이 바뀐다면, 그들은 겁에 질려 버립니다.

우리는 이 친밀한 문제에 대해 실제로 이야기할 것입니다. 강의를 덧붙여야 한다는 것을 기억해야 할 것입니다.

프로토콜과 골화에 대해서만 말씀드리겠습니다.

매우 중요한 개념이에요.

저게 뭔데요?

저는 각각 특정 네트워크 구성 요소를 설명하는 7개 계층을 모델링했습니다.

오른쪽.

7번째 계층은 응용 프로그램입니다.

그건 엔지니어들조차도 이해하지 못하는 부분이에요.

그들은 실제로 7계층과 직접 상호 작용하지 않습니다.

일반적으로 응용 프로그램 위에 있습니다.

네트워크 엔지니어에게 7계층을 살펴보면 그것은 단지 들어오는 데이터일 뿐이지만,

엔지니어가 돌아와서, 그들은 다양한 라이브러리를 사용하고, 듣고, 보내고 있습니다.

패킷과 그들이 사용하는 패킷은 아마도 gRPC, 알다시피 프로토콜 또는 특정 프로토콜일 것입니다.

HTTP 2 위에, 어느 것이, 어느 것이, 어느 것이 점점 더 많은 패킷을 생성하는지 알다시피, 하지만 그게

여기서 정말 중요한 것은 바로 응용 프로그램입니다.

여기서의 응용 프로그램은 정말 방대하며, 모든 사람이 그 계층을 다르게 보고 있습니다.

하지만 우리에게는 그 이상의 모든 것이, 아시다시피, HTTP는 응용 프로그램이거나 FTP입니다.

또는 이 레이어에 있는 C 무엇이든.

이것은 실제 애플리케이션 계층이며, 직렬화를 인코딩하여 전송한 프레젠테이션 계층입니다.

JSON은 fetch나 Axios를 통해 바로 가져올 수 있습니다.

JavaScript 또는 Python을 사용하는 경우 JSON을 이 JSON 개체에서 직렬화해야 합니다.

배열의 집합이나 문자열에 이르는 데이터 구조와 같은 것인데, 이것은 6번째 계층에서 발생합니다.

당신은 신경 쓸 필요 없지만, 이런 일은 이미 당신에게 일어나고 있습니다.

그러니 신청서보다 조금 낮은 수준이에요.

귀하의 애플리케이션은 전체 객체를 전송하지만 인코딩 변환은 그곳에서 발생합니다.

직렬화.

아, 이건 UTF 8이네요.

인코딩해 보겠습니다.

그러니 아랫부분이 역할을 합니다.

그래서 이런 것에 대해 이야기하면, "잠깐만요, 누가 신경 쓰겠어요?"라고 말할 수 있을 겁니다.

오른쪽?

오른쪽.

누가 신경 쓰겠어?라고 말할 수도 있을 겁니다.

인코딩과 직렬화에 대해서요.

이런 일이 제 지원서에서 발생하고 있으며, 사람들이 실망하는 이유가 바로 이겁니다.

OSI 모델에 대해 사람들은 "정말이에요?"라고 묻습니다.

이걸 꼭 깨야 해요.

정말 세부적인 사항이에요.

나는 상관하지 않아.

아시다시피, 때때로 이것은 프레젠테이션 계층과 세션 계층에 대한 비판 중 하나입니다.

어떤 경우에는.

TCP TCP IP 모델이 이것을 단순화하는 이유를 알고 계시겠지만 저는 여전히 Uhs-i 모델을 선호합니다.

어떤 면에서는 우리가 익숙해서 슬라이드로 돌아가는 거죠.

그래서.

응.

여기가 프레젠테이션 계층이에요.

그 다음에는 세션 계층이 있습니다.

아시다시피 세션 계층은 TLS가 발생하는 곳이고 연결이 설정되는 곳입니다.

상태가 효과적으로 위치를 설정하는 곳, 즉 클라이언트에 상태를 저장하는 곳을 알고 있습니다.

당신이 상태를 말하면, 상태는 서버에 상태를 저장합니다.

그래서 일부 프로토콜을 상태 저장형(stateful)과 무상태형(stateless)이라고 부릅니다.

HTTP에는 상태 비저장 프로토콜이기 때문에 세션 계층이 없습니다.

TCP는 상태 기반 프로토콜이에요.

서버에 상태를 저장하고 클라이언트에 상태를 저장하여 세션을 효과적으로 관리할 수 있습니다.

그리고 이 세션이 효과적으로 파괴된 경우, 연결을 다시 시작하거나 무효화할 수 있습니다.

그래서 세션 계층은 효과적으로 다시 한번 확인합니다. 많은 사람들이 "안녕, 정말 정말 너야"라고 말합니다.

원하다.

이건 진짜 세션 레이어 같아요.

정말.

세션에 대해서만 이야기하려면 전체 레이어가 필요합니다.

믿으셔도 됩니다. 이 세션은 실제로 이런 것입니다.

이 층은 실제로 중요합니다.

Linker DI와 같은 많은 프록시는 실제로 세션 계층에서만 논리를 구축한다고 믿습니다.

연결 설정.

그들은 어떤 논리를 펼칠 것이다.

따라서 해당 애플리케이션은 연결을 캡처하여 저장하기 때문에 5계층 앱입니다.

아니면 그것에 대해 의견을 모으는 거죠.

그러니까 5번째 레이어 앱이군요.

이것이 의미하는 바입니다. 즉, 귀하의 애플리케이션이 7계층이거나 이것이 7계층 프록시인 경우입니다.

프록시를 위한 계층.

그들은 이것에 대해 잠깐 이야기합니다.

좋아요, 교통은 가장 중요한 것 중 하나인데, 솔직히 말해서 4계층과 7계층에 속합니다.

백엔지니어로서 가장 걱정되는 일이 두 가지가 아닐까요?

안녕하세요, DevOps를 조금만 적용하면 3계층에 관심을 갖게 될지도 모릅니다.

두 번째 층.

RPE 세션을 구축하고 Keep Alive와 같은 작업을 수행할 때 우리는 걱정할 것입니다.

이것에 대해서 말하고 싶지만, 우리는 여기 살고 있어, 자기야.

우리는 4층과 7층에 살고 있어요.

우리는 대개 4번째 레이어를 구축합니다.

구성한다는 것은 반드시 빌드를 의미한다고 할 수 없지만, 애플리케이션을 4계층 앱으로 구성한다는 의미입니다.

왜?

그게 무슨 뜻이에요?

즉, 우리는 운송수단을 알고 있다는 뜻입니다.

즉, 우리는 패킷을 알고 있다는 뜻이죠?

이것을 패킷이라고 부르지 않습니다.

TCP 및 데이터 전송 측면에서는 세그먼트라고 합니다.

DB 그렇군요.

잠깐 이 명명에 대해 구체적으로 설명하겠습니다.

당신은 과정을 건너갈 것이고, 당신은 이것에 대해 걱정하고 이해할 것입니다.

매우 분명해요.

하지만 실제로는 이런 식입니다.

TCP UDP 맞습니다.

매우, 매우 중요한 개념이에요.

해당 프로토콜은 여기에 있습니다.

솔직히 말해서 이 두 가지 프로토콜만 있습니다.

운송에 관한 다른 프로토콜은 있고, 없습니다.

글쎄요, 카운트 퀵을 그 일부로 부를 수도 있어요.

매우 새로운 빠른 프로토콜이 있는데, 거의 새로운 것이지만 전송 프로토콜입니다.

하지만 그게 전부였습니다.

아시다시피, 이게 세 가지 프로토콜이고 모든 게 이 세 가지를 기반으로 구축되었어요.

HTP TCP STB 2, TCP STB 3 위에 구축된 Quick Quick은 UDP 위에 구축되어 있습니다.

결국 TCP나 UDP를 기반으로 구축됩니다.

거기.

아무것도 없습니다. 아무것도 없습니다.

IP(3계층, IP 프로토콜)에서 직접 애플리케이션을 빌드하고 멋지게 만들 수 있습니다.

인터넷 프로토콜.

여기에는 운송 개념이 없습니다.

패킷이 도착하든 도착하지 않든 상관없어요.

최선을 다하겠습니다.

나쁜지 말해줄게요. 하지만 뭐, 결정은 여러분의 몫이죠.

이는 네트워크 프로토콜입니다.

알다시피, 그건 IP로 전송되는 패킷이에요.

여기서는 포트에 대한 가시성이 있습니다. 포트 80, 포트 80, 80.

여기.

우리는 항구가 무엇인지 모릅니다.

우리는 주소, IP 주소만 알고 있습니다. 그래서 각 계층에는 아름다운 개념이 도입되었습니다.

그것으로, 알다시피, IP에는 라우팅 개념과 IP 주소가 있는데, 우리가 그걸 가지고 가는 거죠.

전체 섹션에 설명이 필요합니다.

계속 지켜봐 주시기 바랍니다.

아름다운 것이 곧 나올 거예요.

아름다운 것이 곧 나올 거예요.

두 번째 계층은 또 다른 중요한 개념입니다.

두 번째 계층은 데이터 링크 계층입니다.

여기서 우리는 물리적 매체를 다루고 있습니다.

결국 물리적 네트워크 주소, 예를 들어 이 Wi-Fi에는 MAC 주소가 있습니다.

나는 그것에 프레임을 보내고 싶다.

그래서 우리는 프레임과 2계층을 보내고 있으며 IP 주소에 대해 알고 있는 것과 모르는 것이 있습니다.

이 층.

아무것도 아님.

우리는 Mac 주소에 대해서만 알고 있습니다.

그래서 차드와 우리가 사용하는 프로토콜은 이더넷, WiFi 802 또는 그 무엇이라고 불리든,

프레임 내부의 프레임과 두 번째 레이어.

저는 이 내용을 강의 중에 백만 번이나 반복할 겁니다.

우리는 2계층에서 프레임을 보내고, 3계층에서 패킷을 보내고, 4계층 TCP에서 세그먼트를 보냅니다.

UDP와 관련해서 우리는 데이터 그램을 설정합니다. 세그먼트라고도 합니다.

그리고 두 가지 모두에 대해, 이것이 옳지 않다면 나를 고소할 수 있습니다.

괜찮은.

하지만 걱정하지 마세요.

용어는 물리적 계층에 많이 사용됩니다.

이것이 바로 베어메탈입니다.

무엇이 무엇이고 무엇이란 말인가?

프레임을 취한 후, 그것이 어떻게 다른 매체로 전송되나요?

이더넷에 관한 전기 신호는 광섬유와 빛, 빛파입니다.

전파인가요? Wi-Fi나 LTE인가요?

이 모든 것, 즉 물리적인 것.

그리고 이런 측면에서 보면, 결국은 전파이거나 빛이나 전기일 뿐입니다.

하지만 결국 누군가가 그 전기 신호를 다시 2계층 프레임으로 변환해야 합니다.

글쎄요, 먼저 디지털 101010으로 변환한 다음 다시 프레임으로 변환합니다.

그런 다음 프레임이 IP로 변환되고, 그런 다음 IP를 데이터 조각으로 가져와 이해합니다.

TCP 세그먼트를 통해서 우리는 '아, 여기에 세션이 있는 걸까?'라는 질문을 이해하게 됩니다.

이 경우에는 상태가 필요하며 디코딩하고 직렬화하여 애플리케이션에 전달해야 합니까?

예를 들어, 아름다운 HTTP 요청을 처리할 수 있나요?

실제로 예를 들어보겠습니다.

보낸 사람의 관점에서.

우편 요청을 보냅니다.

그리고 본문을 보내야 하기 때문에 특별히 게시물을 작성했는데 요청이 제대로 이루어지지 않아서 본문을 보낼 수 없습니다.

그래서 글을 올려야겠어요.

따라서 여기 https 웹 페이지에 게시물 요청을 보내는 것은 암호화되어 있다는 의미이므로 TLS가 있습니다.

여기서는 다루지 않지만, 나중에 다루겠습니다.

JSON 데이터를 HTTP 서버에 요청하는 애플리케이션 게시는 애플리케이션이 수행하는 작업입니다.

하다.

Axios를 사용하거나 fetch를 사용하거나 Python 요청 라이브러리를 사용하여 게시 요청을 보냅니다.

JSON 덩어리를 사용해서 "이걸 보내세요"라고 말합니다.

프레젠테이션 계층은 JSON 객체를 가져오는데, 이는 여기의 객체일 뿐이며 이를 플랫으로 직렬화합니다.

바이트 문자열.

오른쪽.

물건을 보냈다고 해서 아무 의미가 있는 건 아니잖아요?

해당 객체는 귀하의 언어로만 의미가 있습니다.

네, 그렇습니다.

그것이 끈일 경우에는 아무 의미가 없습니다.

바이트로 변환해야 합니다.

오른쪽.

그리고 이 바이트를 데이터 묶음으로 여기에 밀어넣습니다.

이제 JSON과 프로토콜이 있고, 다른 것들도 있습니다.

정보 세션에 대한 정보입니다.

TCP 연결을 설정해야 합니까?

TLS를 설정해야 하나요?

네, 네.

네, 네.

우리는 통신이 필요하기 때문에 TCP 연결을 설정합니다.

우리는 이 모든 아름다운 것들을 설명해 드리겠습니다.

GCP 연결, TLS가 실제로 무엇을 의미하는지 잠시 후에 설명해 드리겠습니다.

그래서 암호화가 이루어지는 거죠.

세션에서 무슨 일이 일어났는지 알려드리겠습니다.

상태 전송을 시작하려면 4, 4, 3 포트로 요청 대상을 보내야 합니다.

그래서 그게 우리가 실제로 보내는 첫 번째 내용이에요.

오른쪽.

연결을 설정하려면 Send를 보내야 하기 때문에 이것은 세션 계층의 직접 명령입니다.

간식 행위.

오른쪽.

우리는 이것에 대해 이야기할 것입니다.

혼란스러우시더라도 걱정하지 마세요. 하지만 데이터를 보내지 말고, 보내기 요청만 보내세요.

우리는 여기에 포즈를 취했습니다.

JSON은 사라지지 않고, 아직 상대방에게 전달되지 않습니다. 아직 연결이 되지 않았기 때문입니다.

따라서 연결을 설정하고 연결 요청을 수신한 후 인증한 다음 보냅니다.

데이터는 여기에 있습니다.

하지만 여기서 잠깐 보내기 요청을 보낸다고 가정해 보겠습니다.

Syn은 4, 4, 3번 포트로 보내집니다.

왜?

운송 수단은 항구가 무엇인지 알고 있기 때문입니다.

왜 4, 4, 3이에요.

음, https라고 하셨는데, 그게 기본 포트예요.

넷, 넷, 넷, 셋.

우리는 이 네트워크와 저 네트워크의 포트, 즉 네트워크 계층을 4, 4, 3으로 이해합니다.

우리는 세그먼트를 IP 패킷으로 압축하고 소스와 대상을 추가하는 전송 요청을 밀어 넣습니다.

저작권(IP)

따라서 IP 주소가 필요한 경우 DNS를 통해 IP 주소를 얻어야 합니다.

그리고 IP 주소를 얻으면 그것을 이 패킷에 집어넣습니다.

걱정하지 마세요. 우리는 그 모든 것을 설명하는 아름다운 다이어그램을 제공할 것입니다. 그러나 데이터 링크는

각 패킷은 단일 프레임으로 들어가 소스 및 대상 Mac 주소를 추가합니다.

그러니까 맥도 알아내야 해요.

이것이 ARP이고 이에 대해 말해보죠.

각 프레임은 물리 계층에서 비트 문자열이 됩니다.

정확히 10101010이에요.

이 1과 0은 라디오 신호나 전기 신호나 빛으로 변환되고 그게 전부입니다.

이 말은 믿지 마세요.

여기서 설명하는 내용은 그들이 말하듯이 명확하고 단순할 필요는 없습니다.

아시다시피, 일부 계층은 서로 상속을 받아 특정 작업을 수행할 수 있습니다.

그리고 인간이 이것을 만들었습니다.

아시다시피, 아무것도 그냥 4층, 5층일 뿐인 것은 아닙니다.

당신은 그 모든 것에 대해서 논쟁할 수 있습니다.

수신기 수신기는 무슨 일을 하나요?

수신기는 물리 계층을 먼저 수신하게 되는 건가요?

아, 우리는 라디오나 전기 신호를 많이 받았지?

서버가 광섬유에 연결되어 있어도 네트워크는 Wi-Fi에서 보낼 수 있습니다.

아름다운 사람들을 보시나요?

이것의 아름다움을 알아보시나요?

와이파이로 데이터를 보낼 수 있나요?

그리고 그것은 섬유를 통해 전달됩니다.

당연하다고 말할 수도 있겠지만, 저는 정말 고맙습니다.

알다시피, 이제 수신기 측의 물리적 계층에서 이것을 디지털 비트로 변환한 다음,

데이터 링크.

좋아요?

오, 1번째 레이어의 비트는 심볼이고 프레임이에요.

2계층의 프레임은 IP 패킷으로 조립됩니다.

오, 이제 IP 패킷의 대상 IP 주소가 이것이라는 걸 알게 됐어요.

네, 그렇습니다.

오른쪽.

그런데 모든 라우터도 똑같은 질문을 합니다.

저는 그 점에 대해 이야기하겠습니다.

이 패키지가 나한테 맞는 걸까?

따라서 전송, 3계층의 IP 패킷은 모두 TCP 세그먼트로 조립됩니다.

오른쪽.

그리고 혼잡 제어나 흐름 제어, 무역 전송을 처리하고 이게

이거 쌀 봉지 맞나요?

이게 오래된 패킷이에요?

이게 새로운 건가요? 그리고 모든 물건을 주문할 거예요.

세그먼트가 죄라면 우리는 아직 처리 중이므로 더 이상 레이어로 이동할 필요가 없습니다.

연결 요청.

이게 바로 아름다운 점이죠?

연결 요청이기 때문에 실제로는 다운되지 않습니다.

세션 계층까지 내려갈 이유가 없습니다.

그럼, 연결을 설정하려면 세션 계층으로 가야 합니다.

그리고 연결이 되면 다음 요청에서 JSON을 다시 받게 됩니다.

여기 연결 부분까지 다 갈게요.

그리고 우리는 이 지역으로 갈 거예요.

우리는 프레젠테이션 레이어를 만들 것입니다.

이는 앱에서 사용할 수 있도록 문자열 JSON을 JSON 객체로 다시 보내는 것입니다.

그리고 여기의 이 직렬화는 여기에서 일어난 직렬화와 완전히 다를 수 있습니다.

클라이언트는 JavaScript에서 직렬화할 수 있기 때문에 가능하지만 이것은 Python으로 직렬화되거나

C 샤프에서 D로 직렬화할 수도 있고, Go로 직렬화할 수도 있습니다. 상관없습니다.

그게 바로 당신의 논리예요.

그래서 많은 사람들이 프레젠테이션과 애플리케이션 계층은 단지 애플리케이션일 뿐이라고 말하는 것입니다.

솔직히 말하자면.

이것이 응용 프로그램입니다.

제 지원서는 결국 이런 논리를 따르고 있고, 이에 대해서는 반론이 가능합니다.

물론, 다시 한번 말씀드리지만, 이 말은 믿지 마십시오.

애플리케이션은 JSON 요청을 이해하고 "Hey, your express JSON or Apache request at at"라고 말합니다.

이벤트 수신이 끝나면 누군가가 당신을 보냈다는 내용의 이벤트가 트리거됩니다.

게시물 요청을 어떻게 처리하고 싶으신가요?

호출되는 함수는 트리거되어 "누군가가 당신에게 요청을 보냈습니다."라고 알려줍니다.

요청을 소비하고 데이터베이스로 이동하여 작업을 수행한 다음 동기적으로 다시 가져올 수 있습니다.

클라이언트에게 다시 응답합니다.

괜찮은.

마지막으로 몇 가지 다이어그램입니다.

그래서 이 다이어그램을 만드는 데 시간이 꽤 걸렸습니다.

여러분이 좋아할지 봅시다.

그래서 첫 번째 클라이언트는 클라이언트와 서버가 아래로 가거나 위로 가는 화살표를 알아차립니다.

이 경우 클라이언트가 송신자이고 서버가 수신자라는 것은 서버가 송신자라는 것을 의미하지 않습니다.

데이터를 전송하지 않습니다.

또한 데이터를 전송할 수도 있습니다.

따라서 애플리케이션 계층은 프레젠테이션으로 이동합니다.

우리는 직렬화, 디코딩, 인코딩 등에 대해 이야기합니다. 바로 이러한 계층을 구축하는 것입니다.

연결, 이것이 TLS이든 핸드셰이크 자체이든, TCP 핸드셰이크는 개념을 확립합니다.

연결, 상태 있는 것, 그런 다음 TCP 흐름 제어를 사용하여 실제로 작업하는 전송

포트와 그런 모든 것들, 아시죠, 실제 세그먼트는 네트워크로 내려가죠, 그렇죠?

IP 패킷 자체는 데이터 링크를 통해 전송됩니다.

이건 노란색이에요.

이 오렌지.

명확한지 모르겠네요.

희망적으로는 명확할 겁니다.

다행히도 저는 이러한 색상 선택을 후회하지 않을 것입니다. 아시다시피, 실제적인 물리적 계층이죠.

중간.

그리고 우리는 그것을 보내고, 나는 파도를 선택했습니다.

이 경우 서버는 우리가 물리적 매체로부터 먼저 그것을 받았다는 것을 알게 됩니다.

우리는 물건을 받습니다.

아시다시피 가장 낮은 계층은 네트워크 카드가 이 신호를 수신한 다음 이를 데이터로 변환하는 것입니다.

링크를 클릭한 다음 다시 IP 주소로 변환합니다.

이제 IP 패킷은 모든 경로로 전송되고 세션은 프레젠테이션으로 이동하여 모두 이동합니다.

신청서.

그러니까 그냥 경로를 정하면 되고, 마우스를 보면 되죠.

그리고 쭉 위로 올라가세요.

바로 이렇습니다.

바로 당신이에요.

지금.

갑시다.

질문은, 항상 이 모든 단계를 거쳐야 하나요?

전혀 그렇지 않습니다.

예를 하나 들어보겠습니다.

TCP를 보내면.

아니, 가자.

Stevie Post 요청을 보내는데, 새로운 연결을 설정해야 합니다.

그러면 해당 애플리케이션이 요청을 보냅니다.

아시다시피, 프레젠테이션은 JSON 방식으로 진행되고, 세션은 일시 정지되고, 프레젠테이션은 종료됩니다.

나는 "잠깐만요, 세션"이라고 말했습니다.

여기에는 세션이 없습니다.

무슨 얘기를 하는 건가요?

세션을 생성해 보겠습니다.

잠깐만요.

잠깐 기다려요.

잠깐 세션을 만들어 보겠습니다.

그래서 우리는 2주, 2주, 2주, 2주, 2주, 2주, 2주 후에 요청을 보냅니다.

연결을 만들기 위한 요청을 보냅니다.

여기까지입니다.

이 포인터가 보이네요.

요점을 파악하는 게 중요해요.

그렇지 않으면 모든 것이 무의미해집니다.

보이죠?

세션에 접속하세요.

좋아요.

동의해요.

연결을 만들겠습니다.

우리는 올라가지 않아요.

우리는 그렇지 않아요.

아무 의미가 없습니다.

아직 신청서가 없습니다.

이는 여기에 연결을 보내라는 요청을 보내고, 연결을 설정하라는 요청일 뿐입니다.

그리고 우리는 센드 ec bum, bum, bum, bum, bum bum bum bum bum, bum, bum bum을 설정합니다.

돌아가는 것은 알겠습니다, 당신의 여유를 받습니다.

마지막으로 돌아가기 위해 할 일을 하고 여기서 세션을 멈추면 이제 완전한 연결이 이루어졌습니다.

이제 세션에서 '확인'이라고 나오면 EC를 보냈으니 잠금을 해제하고 더 진행할 수 있습니다.

좋습니다. 다음 세션으로 넘어가겠습니다.

계속하다.

JSON 요청이 다시 시작되었음을 기억하세요.

전송 계층으로 가거나 세그먼트에 넣어주세요.

이는 바이트, 문자열 JSON을 전송 계층에 넣고 IP 패킷에 밀어넣고 결정합니다.

목적지의 IP 주소를 데이터 링크에 넣고 MAC 주소를 확인합니다.

물론 우리는 이미 악수에서 그 모든 것을 결정했지만 여기서 다시 설명하겠습니다.

그리고 물리 계층을 보내서 모든 데이터를 전송하고 끝까지 전송합니다.

전송 계층으로 이동하세요.

세션이 있습니다.

네, 프레젠테이션 레이어를 담당하고 있습니다.

어떻게 해야 하나요?

아름다운 JSON이 있고, 모든 데이터가 있는데, 이게 하나일 수도 있어요.

패킷 또는 세그먼트, 혹은 배수라고도 할 수 있습니다.

따라서 이렇게 하면 필요한 모든 패킷을 조립한 다음 하나를 전달하게 됩니다.

이를 디코딩하거나 직렬화할 프레젠테이션 계층에 대한 거대한 문자열이 애플리케이션으로 돌아갑니다.

그리고 갑자기 당신은 그 교훈을 촉발시켰고, 그게 포스트라고 불리는 이유인 줄 알죠.

라우터라면, 여기서처럼 Express를 사용한다면, 지금은 트리거일 뿐입니다.

그러니 작품을 살펴보세요.

그런 일이 일어나고 있습니다, 여러분. 그리고 그것이 바로 이 과정의 목적입니다.

무슨 일이 일어나고 있는지 이해하는 것은 아름다움입니다.

그 말이 무슨 뜻인지는 모르겠지만 요점은 알겠죠.

괜찮은.

그러니까 이건 세그먼트예요.

이게 패킷이고 이게 프레임이에요.

나는 그와 이것이 세그먼트에서 다시 프레임으로 고정될 때까지 이것을 백만 번 반복할 것입니다.

이것을 이해하는 것은 매우 중요한데, 제가 좋아하는 또 다른 견해도 있습니다.

저는 개인적으로 그렇게 생각합니다.

이전에 누군가가 이런 일을 하는 것을 본 적이 없습니다.

제가 이해한 바는 다음과 같습니다.

꼭 그렇지는 않아요.

전선에서는 이렇게 보입니다.

알다시피, 네가 잘 보이거나 내가 이렇게 보일 거라면, 나는 이것을 봐요.

이것은 러시아의 마트료시카입니다.

이 사실을 알고 계시다면, 이 인형은 인형 안에 있습니다.

이는 애플리케이션 내의 모델이 정확히 무엇인지 보여줍니다.

프레젠테이션 계층으로 가서 세션 계층으로 가면 여기의 콘텐츠가 TCP 세그먼트로 이동합니다.

대상 포트와 소스 포트를 왼쪽과 오른쪽에 추가하지만, 꼭 왼쪽과 오른쪽에 추가할 필요는 없습니다.

그냥 문자 그대로 끝에 있는 거예요.

하지만 저는 이렇게 하는 것을 좋아합니다. 더 잘 이해할 수 있기 때문이죠.

그리고 이 녹색 세그먼트는 IP 패킷에 삽입되고 이 IP 패킷에 이제 추가해야 합니다.

대상 IP 주소와 소스 IP 주소를 입력한 다음 전체 IP 패킷을 밀어 넣습니다.

프레임이 있는데, 우리 프레임에 더 잘 들어맞아요.

그리고 MTU 최대 전송 단위라고 불리는 프레임 크기에 대해서 이야기해 보겠습니다.

조각화하지 않는 한 IP 주소 IP 패킷을 여러 프레임에 넣을 수 없습니다.

우리는 미래에 이야기할 것입니다.

목적지 Mac과 소스 Mac을 거기에 넣으면 전체가 이 빨간색이 됩니다.

라디오 신호 덩어리를 가지고 우리도 똑같은 일을 할 거예요.

여기요.

물리적 계층에서 바로 베팅을 시작하세요.

프레임이 시작되는 곳과 끝나는 곳을 이해해야 합니다. 그게 바로 물리 계층의 역할이기 때문입니다.

그리고 실제로 그들은 죽음에 이르렀습니다.

치유는 당신을 위해 그런 일을 합니다.

그리고 이제, 여기에 Mac 주소가 있습니다.

우리는 출처를 가지고 있어요, 맥.

IP 패킷이 되는 이 프레임의 데이터 부분을 가져옵니다.

안녕하세요, 이것이 목적지 IP입니다.

여기가 소스 IP입니다.

당신은 이것을 보지 못해요.

이게 여기 저 프레임에 밀어넣어진 거예요.

오른쪽.

짐을 풀어야 해요.

짐을 푸는 데는 한정된 시간이 걸린다.

나노초라면 그럴 수 있겠죠.

아시죠, 이 나노초 단위를 이해하는 것이 매우 중요합니다.

그러니 앞으로 나아가세요.

IP 패킷을 받으세요.

우리는 무엇을 하나요?

IP 패킷.

안녕하세요, 목적지 IP입니다.

나에게 맞는 걸까?

예.

그 부분을 보세요.

우리는 무엇을 하나요?

세그먼트.

뒤쪽에.

이것이 목적지인 시어스포트 항구에는 세그먼트 구분이 있습니다.

여기에는 수천 개의 항구가 있습니다.

아, 이 항구를 원하시나요?

좋습니다. 해당 세그먼트를 해당 애플리케이션, 해당 프로세스에 전달하겠습니다.

항구에 기반을 두고 있기 때문에 이런 방식으로 배달하게 될 거예요.

오른쪽.

그리고 우리가 설명할 것도 있습니다.

각 포트는 기술적으로 하나의 프로세스이고 하나의 포트입니다.

물론 이는 바뀔 수 있지만, 이는 단지 일반적인 경험 법칙일 뿐입니다.

그리고 나서 우리는 이해하게 됩니다.

나와 연결되어 있나요?

네, 그렇습니다.

프레젠테이션 계층에서 뭔가 해야 하나요?

아니요.

여기서 신청할 때 별도로 해야 할 일이 있나요?

그리고 우리는 앱을 효과적으로 제공합니다.

여기 이해하는 것이 매우 중요한 또 다른 슬라이드가 있습니다.

클라이언트가 서버에 직접 연결되어 있지 않다는 걸 알고 계시죠?

이 사람이 고객입니다.

이것이 서버입니다.

중간에 스위치가 있는데, 그 스위치는 프록시인 외부 스위치이고, CD 인은 역방향 스위치입니다.

프록시.

로드 밸런서가 있죠.

저 놈들은 가운데에 뭐하는 거지?

그들은 콘텐츠를 살펴보고, 콘텐츠를 엿보고, 콘텐츠를 엿볼 때 제한된 시간이 소요됩니다.

그들은 데이터의 정점에 따라 결정을 내리기 때문입니다.

괜찮은.

이제 클라이언트가 서버와 통신을 원하지만 스위치로 이동하는 예를 살펴보겠습니다.

라우터 맞죠?

따라서 클라이언트는 평소와 같이 정보를 보냅니다.

아시다시피, 클라이언트는 평소처럼 해당 정보를 원하고 애플리케이션 프레젠테이션 세션을 진행합니다.

전송망 데이터와 물리적인 끝부분을 연결한 후 전송합니다.

오른쪽.

귀하의 조직에서 가장 먼저 접할 수 있는 일은 아마도 스위치를 켜서 다른 것들을 연결하는 것입니다.

서브넷을 함께 묶어서, 알다시피, 이건 서브넷 작업이고, 이건 이 네트워크의 서브넷이에요.

저는 이 두 네트워크를 서로 연결하고 싶고, 불필요하게 다른 네트워크로 데이터가 전송되는 것을 원치 않습니다.

아시죠, 그것이 스위치의 힘이에요.

아시다시피, 프레임 자체와 MAC 주소를 기반으로 데이터를 어디로 보낼지 이해합니다.

그게 바로 요령이에요.

마치, 이 컴퓨터는 이 포트에 연결되어 있군요.

그러니까 그 Mac 주소는 이거예요.

그래서 그것은 이 포트로 가는데, 예를 들어 허브와 꼭 다르지는 않습니다.

문자 그대로 허브는 모든 포트에 데이터를 브로드캐스트하는데, 이는 엄청난 대역폭입니다.

낭비가 발생합니다.

그러나 스위치가 작업을 수행하려면 MAC 주소를 확인해야 합니다.

조회.

그러니 물리적인 계층만 있으면 됩니다.

그것을 데이터 링크로 변환하고 프레임을 살펴보고 대상 Mac 주소를 살펴본 다음,

그것.

IP 주소는 더 이상 필요하지 않습니다.

대부분의 스위치는 그렇지 않지만, 일부 스위치는 그렇습니다.

하지만 대부분의 스위치.

두 번째 층만 보세요.

다 그거죠.

그리고 한 번 그렇게 되면, 좋아, 끝났구나 하는 생각이 듭니다.

그리고 다음 보드로 데이터를 전송합니다.

오른쪽.

그러니까 여기서 생각해 보면, 데이터를 다시 전송하는 거죠.

이제 라우터를 살펴보겠습니다.

라우터도 똑같은 일을 합니다.

라우터에는 물리적 계층이 필요합니다.

당연히 데이터 링크로 갈 거예요.

동일한 서브넷을 통해 전송하는 경우 스위치처럼 작동할 때가 있습니다.

하지만 가장 중요한 것은 라우터가 라우팅해야 하고 라우터에는 IP 주소가 필요합니다.

경로이므로 3번째 계층까지 올라가야 합니다.

경로를 지정합니다.

이것이 라우터가 3계층 장치인 반면 스위치는 2계층 장치인 이유입니다.

이해하기 매우 중요한 개념입니다.

그래서 당신은 위로 올라가고 우리는 아래로 내려가 라우터가 3계층까지 올라가고 그 다음에 갑니다.

아래에.

그리고 애플리케이션에 도달할 때까지 여러 라우터를 거쳐야 하며 레이어로 올라가야 합니다.

3개로 내려가서 3번째 레이어까지 내려가서 애플리케이션에 도달할 때까지 내려가서 끝까지 가세요.

필요한 경우 신청서에 첨부합니다.

다시 말해서, 때때로 연결을 설정하고 레이어 세션으로만 이동하고 싶을 때가 있습니다.

세션 계층이나 패킷이 유효하지 않은 경우가 있고 여기서 바로 실패할 수도 있습니다.

나는 "당신은 인맥이 없군요"라고 말했습니다.

왜?

연결 없이는 나에게 데이터를 보낼 수 없습니다.

아시다시피, 그것은 실질적으로 TCP ID입니다.

그래서 UDP에는 세션 계층이라는 개념이 실제로 없는 것입니다. 생각해 보면 그럴 수도 있습니다.

거기에는 오류가 있지만, 생각해보면 UDP에는 상태가 없습니다.

UDP는 상태를 저장하지 않습니다.

그냥 데이터를 보내면 됩니다.

국가가 없습니다.

하지만 그건 매우 중요한 개념이기도 해요.

제가 가장 좋아하는 건 방화벽을 추가하는 거예요.

프록시를 위한 레이어를 추가해 보겠습니다.

CDN 콘텐츠 관리 콘텐츠 전송 네트워크를 추가해 보겠습니다.

그럼 방화벽은 뭐하는 걸까요?

우리 블록의 경우 특정 애플리케이션이 데이터나 블록을 전송하는 것과 블록이 원하지 않는 특정 패킷을 전송하는 것입니다.

귀하의 네트워크를 통해서 오세요.

그러기 위해서는 IP 주소를 살펴봐야 합니다.

항구를 살펴봐야 합니다.

그래서 최소한 포트와 일부 방화벽이 끝까지 가서 애플리케이션을 살펴보는 것입니다.

여기를 올려다보는 방화벽이 있습니다.

이를 효과적으로 투명한 방화벽이라고 부릅니다.

투명 방화벽이나 투명 프록시는 ISP처럼 정말 투명합니다.

여기까지의 내용은 누구나 이용할 수 있습니다.

누구나 당신의 포트를 읽을 수 있고, 누구나 당신의 IP 주소를 읽을 수 있습니다.

그렇기 때문입니다.

공개되어 있어요.

그렇지 않아요.

암호화된 적은 없습니다.

절대.

필요한 네트워크 IP 주소.

데이터를 라우팅하려면 IP 주소가 필요하고 포트도 공개되어야 합니다.

괜찮은.

그러니 이것들은 공개적입니다.

그래서 이걸 보는 사람들은 투명, 투명 방화벽, 투명이라고 부르죠.

프록시, 혹시 이런 걸 들어보셨나요?

이것들은 프록시입니다.

실제로는 아무것도 바뀌지 않습니다.

거의 이식과 같아요.

그들은 그것을 살펴보고 이것이 ISP가 기술적으로 귀하가 그들이 접속하는 모든 웹사이트에 가는 것을 차단할 수 있는 이유입니다.

원하다.

그들은 당신이 그곳에 가는 것을 원하지 않습니다.

많은 정부에서는 투명한 대리인을 사용합니다.

아시다시피, 그들은 신청서까지 다 가지 않습니다. 신청서를 작성하려면 다음이 필요하기 때문입니다.

암호를 해독하려면 세션을 중지하고 암호를 해독해야 합니다.

오른쪽.

그렇게 하려면 서버의 인증서를 제공해야 하는데, 그게 없는 경우가 아니라면요.

당신은 카자흐스탄인데, 문자 그대로 국민의 모든 컴퓨터에 인증서를 강제로 삽입하고 있습니다.

이를 신뢰하는 인증 기관에 문의하세요.

하지만 세상 대부분은 그렇지 않아요.

그래서 그들은 항상 투명합니다.

당신이 할 수 있는 유일한 일은 당신이 접속하려는 IP 주소를 차단하는 것 뿐입니다.

당신은 그것을 할 수 있어요.

당신이 해야 할 일은 그저 멈추는 것 뿐입니다.

데이터를 바로 보내지 마세요. 데이터가 당신을 거쳐 전달되거든요.

무슨 일이 일어나면, 그것을 막을 수 있습니다.

따라서 방화벽은 프록시를 위해 이 계층을 차단합니다.

포트를 기준으로 로드 밸런싱을 수행하려는 경우

안녕하세요, 8080을 가져올 예정이라면 패킷을 다시 작성하여 이 주소로 보내주시기 바랍니다.

대신에.

아니면 이 주소로 보내주세요.

오른쪽.

그러니까 여기서 패킷을 다시 쓰고 효과적으로 변경한 다음 다른 곳으로 보낼 수 있습니다.

사실, 생각해 보면, 당신도 언제나 그럴 수 있을 거 아닙니까?

원하시면 받으실 수 있고, 다른 곳으로 보내드릴 수도 있습니다.

그들이 원한다면.

제가 인터넷 서비스 제공업체라고 말하는 사람을 아십니까? 인터넷 서비스 제공업체는 첫 번째 패킷이 이동하는 곳이기 때문입니다.

오른쪽.

그래서 많은 사람들이 VPN을 사용합니다.

VPN이 효과적입니다.

여기에는 추가하지 않았지만 VBM은 실제로 3계층 프로토콜입니다.

생각해 보세요.

IP 패킷을 가져와 다른 IP 패킷에 넣습니다.

VPN을 위한 IP에 대한 더 간단하고 간편한 솔루션입니다.

대부분 VPN은 이런 일을 하지 않지만, 한 가지 해결책은 IP에 IP를 넣는 것입니다.

따라서 이 IP 패킷의 내용이 무엇인지는 중요하지 않습니다. IP 요청일 수도 있고 gRPC일 수도 있습니다.

데이터베이스든 물론 상관없어요. IP이니까요.

그렇기 때문에 우리의 측면 모델이 정말로 중요한 것입니다.

알다시피, 그것을 가져다가 거기에 밀어넣고 보내는 거죠.

따라서 VPN은 실제로 3계층 프로토콜입니다.

생각해 보세요.

실제로 그 계층에 살고 있는 사람들도 있습니다.

아니요.

그래서.

파일이나 프록시로 여기까지 오세요.

하지만 7계층 로드 밸런서와 같은 로드 밸런서가 있다면 알겠죠.

엔지니어가 백업용으로 하나를 만들었다면, Gen X처럼 데이터를 캐시하려는 경우와 같습니다.

예를 들어, 어떤 슬래시 사진을 슬래시하려고 하면 특정 경로를 기준으로 균형을 맞춰야 합니다.

오른쪽?

이 서버로 이동합니다.

슬래시 이미지를 사용하면 그림도 똑같은 것입니다.

이미지, 슬래시, 어떤 덩어리든지.

원하시면 이 서버 세트로 이동하세요.

이 경로의 슬래시는 실제로 대부분의 경우 암호화되는 응용 프로그램 개념입니다.

그것을 보려면 암호를 해독해야 합니다.

따라서 7계층 프록시 또는 콘텐츠 전송 네트워크, 즉 7계층이 이 계층에서 작동합니다.

즉, 그들은 당신이 보낸 모든 것을 해독하고, 보고, 캐시한 다음 다시 보낸다는 뜻입니다.

그래서 그들은 그곳까지 갔습니다.

그래서 라우터나 방화벽보다 훨씬 느립니다.

더 낮은 곳은 어디인가요?

위로 쭉 올라가서 모든 것을 다시 아래로 전송해야 합니다.

그러니까 이제 이 두 퍼피 사이에는 완전히 다른 세션이 필요한 거죠.

왜냐하면 이 세션은 하나의 세션이고, 이것도 하나의 세션이기 때문입니다.

이것이 고객인 당신에게 있어서 최종적인 종착지입니다.

여기로 연결 중입니다.

아시다시피, 이것을 역방향 프록시라고 부르는 이유가 여기에 있습니다.

이것이 당신의 최종 목적지가 어디인지 알고 있지만, 실제로 당신의 진정한 최종 목적지는 이 백엔드입니다.

당신이 아무것도 모르는 서버.

구글은 다른 모든 애플리케이션에서 이런 방식으로 작동합니다.

구글에 접속하면 프런트 엔드 서버는 전혀 건드리지 않습니다.

그냥 그쪽으로 가는 거예요.

하지만 Google 서버는 돌아서서 백엔드의 다른 서버로 요청을 보낼 수 있습니다.

역방향 프록시가 무엇인지 전혀 모르겠습니다.

프록시가 당신을 통과하는 동안 당신은 요청을 보내고 있다는 것을 알고 있지만 최종 목적지는 알고 있습니다.

아시다시피, 당신은 이것이 당신의 최종 목적지라는 것을 알고 있지만 대리인이 당신을 대신하여 그 요청을 하는 것입니다.

이해가 되나요?

좋습니다. 그러면 Orci 모델의 단점은 무엇일까요?

그렇지만?

사이먼은 이해하기 어려울 만큼 층이 너무 많습니다.

그리고 확실히 그것은 3년 전쯤의 내 믿음과 의견이었고 나는 내 마음을 바꾸었습니다.

그 이후로.

저는 정말로 세션과 프레젠테이션에 대해 생각했습니다.

제 생각에는 이건 실제로 하나로 취급되어서는 안 될 것 같아요.

하지만 지금은 더 많이 이해할수록, 더 많이 응용할 수록, 더 많이 읽고 더 많이 읽기 시작했습니다.

우리가 정말로 필요로 하는 낮은 수준의 것을 이해하세요. 가끔씩 분해하는 것 말이죠. 모든 것이 아닙니다.

시간이 지남에 따라 달라지지만, 어느 계층이 무엇을 하는지에 대해서는 논쟁하기 어렵습니다.

사람들은 여전히 ​​"오, 프레젠테이션 계층은 스크립트나 프레젠테이션 계층이 아니어야 한다"고 주장합니다.

결국 OC를 디코딩해야 합니다.

결국 사람들은 모두 추측할 뿐이에요.

그래서 정말 웃기지 않아요.

아시다시피, 모든 사람이 의견을 가지고 있잖아요.

결국 그것은 의견이 됩니다.

오른쪽.

컴퓨터를 보면 5계층이 없습니다.

아시겠지만, 그냥 읽을 만한 내용이 아니죠.

우리가 이야기하는 내용이에요.

그래서 우리 엔지니어들은 사물에 대해 이야기할 수 있죠.

훨씬 더 간단하죠.

5, 6, 7 계층을 처리하는 것이 확실히 더 간단합니다.

그건 하나의 계층, 즉 애플리케이션이고, 그것이 바로 CPI B 모델이 하는 일입니다.

바로 그것입니다.

훨씬 더 간단하죠.

그냥 응용 프로그램 계층이에요, 야, 5, 6/7, 응용 프로그램, 상관없어요, 안 돼요, 안 돼요

상황을 더 복잡하게 만드는군요. 저는 이 문제에 대해 엇갈린 감정을 갖고 있습니다.

전적으로 당신에게 달려 있습니다.

어떻게 생각하나요?

하지만 응용 프로그램에 응용 프로그램이 있는 거 맞죠?

어떤 사람들은 "그거 하지마, 그러지 마, 그러지 마"라고 말합니다.

그냥 한 겹만 바르는 거면 상관없어.

하지만 CPI B 레이어에는 번호를 매기지 마세요.

5층도 아니고 4층도 아니고 3층이에요.

4계층, 3계층 모두 같은 언어입니다. 알다시피 4계층, 3계층 모두 같은 언어입니다.

3개는 외부 모델과 동일하지만 레이어 5는 레이어 5라고 하면 지정해야 합니다.

아, 이게 TCP IP 모델이군요.

즉, 이것은 5계층인 애플리케이션이고 실제로는 세션 계층이기도 합니다.

알다시피, 두 번째 계층에 대해 이야기하는 것은 정말 번거로울 수 있습니다. 같은 거죠.

제가 아는 한, 데이터 링크와 물리 계층은 전혀 언급되지 않는 부분이 맞나요?

그러니까 저는 TCP IP 모델에서 이 계층을 전혀 보지 못하겠어요.

그래서 문자 그대로 TCP IP, 즉 TCP와 IP, 그리고 데이터 링크, 즉 MAC 주소입니다.

그리고 재즈도 있죠.

좋습니다. 이 아름다운 OSI 모델을 요약해 볼까요?

특히 애플리케이션을 작성할 때 가장 중요한 것 중 하나는 다음과 같습니다.

애플리케이션이 어디에 설정되어 있는지 이해하는 것이 정말 좋습니다.

네트워크 기반 애플리케이션인 경우, 데이터가 애플리케이션을 통과하는 경우,

신청서가 어디에 있는지 아는 것이 좋습니다. 신청서를 통해 논의할 수 있고, 무엇을 해야 할지 알 수 있습니다.

최적화할 수 있는 것은 무엇이고, 접근할 수 있는 것은 무엇이며, 무엇을 개선할 수 있습니까?

오른쪽.

매우 중요한 일이죠?

그래서 우리는 OSI 모델에 관해 이야기했습니다.

우리는 방화벽, 프록시 추가, 추가된 많은 예를 보여주었습니다.

역방향 프록시로 콘텐츠 전송 네트워크를 추가했습니다.

그것은 빠르고 그런 것과 같습니다.

모든 CDN은 7계층 역방향 프록시입니다.

그것이 바로 그들이 말하는 것입니다. 알다시피, 그것은 영광스러운 명명입니다. 콘텐츠 전송 네트워크이기 때문입니다.

정의에 따르면 콘텐츠를 저장하고 이에 액세스해야 합니다.

콘텐츠에 액세스해야 합니다.

오른쪽?

오른쪽.

그러니 다시 한번 말씀드리지만, 이 말은 믿지 마십시오.

아시다시피, 각 장치가 7개 계층 모두에 매핑될 필요는 없습니다.

아시죠, 정말 모호하죠.

때때로 경계가 모호한 경우가 있는데, TCP/IP가 확실히 더 간단한 모델입니다.

개인적으로 저는 사물을 좀 더 세부적으로, 세부적으로 나누는 것을 선호합니다.

이제 우리는 세션 5에 대해 이야기하지 않지만 레이어 6은 내가 거의 듣지 못하는 레이어입니다.

사람들이 이야기하는 모든 것.

오른쪽.

하지만 5번째 레이어에서는 누군가가 "저는 사실 5번째 레이어에요. 우리는 플레이하고 있어요"라고 말하는 사용 사례를 보았습니다.

여기는 5번째 층입니다.

링크 링커.

이는 명확한 예이다.

한 명의 사절인 것 같고, 또 다른 사절인 것 같군요.

안녕하세요, 우리는 세션을 관리하고 연결을 직접 관리합니다. 알다시피, 그래서 당신은 그것을 연주하고 있습니다.

세션 계층에서 연주하는 거예요, 연결 계층에서 연주하는 거예요, 연결 계층에서 연주하는 거예요.

하지만 당신은 다른 것에는 전혀 관심이 없습니다.

프록시를 구축하고 있습니다. 결국 링크 카드는 프록시입니다. 그런데 모르셨다면,

저것.

하지만 그렇죠, 여러분.

이 강의를 즐기시기 바랍니다.

다음 글로 넘어가려면 어떻게 해야 하나요?