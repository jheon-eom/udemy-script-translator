이 강의는 공학 분야에서 매우 논란이 많은 주제이기 때문에 이 강의를 가볍게 받아들이고 싶습니다.
공간, 즉 상태가 있는 것과 상태가 없는 것, 상태가 없는 것과 상태가 있는 것이 있습니다.
그리고 정의 게임은 정말 중요하지 않습니다.
여러분, 그게 다예요.
아시죠, 사물의 부작용이죠.
그리고 그게 엔지니어인 우리에게 중요한 거죠.
그러니 강의 전체나 과정 전체는 절대 안 됩니다.
정의에 집중하세요. 오, 이건 이거여야지. 왜냐하면 정의가 이거니까요.
쓸모없는 일이잖아요?
그리고 이건 일종의 이론적인 토론이고, 철학적인 토론이라고 할 수 있을 것 같습니다.
하지만 저는 무엇보다 왜 우리가 어떤 일을 하는 지를 이해하는 것이 매우 중요하다고 생각합니다.
무상태 대 유상태가 그것입니다.
애플리케이션 내에서 상태를 저장하는 스타일입니다.
그리고 나에게 있어서는, 적어도 그 국가가 거기에 있다는 것에 의지하는 것입니다.
그렇지 않으면 물건이 망가집니다.
이것이 무상태와 유상태의 정의입니다.
이것을 시스템에 적용할 수 있습니다.
이것을 백엔드로 가져갈 수 있고, 실제로 함수로 가져갈 수 있습니다. 그리고 이것을 다음으로 가져갈 수 있습니다.
프로토콜
프로토콜은 상태 비저장 프로토콜이거나 상태 저장 프로토콜일 수 있습니다.
모든 것은 당신이 사물을 어떻게 인식하느냐에 달려 있습니다.
시작해 볼까요.
상태 저장형 백엔드와 상태 비저장형 백엔드.
상태 저장이란 무엇인가요?
상태 저장 백엔드는 클라이언트에 대한 상태를 메모리에 저장하는 백핸드입니다.
그뿐만이 아닙니다.
실제로 제대로 작동하려면 해당 정보가 있어야 합니다.
그리고 이것은 당신이 항상 정보를 저장하기 때문에 누구에게나 상태 저장과 큰 차이가 있습니다.
물론 변수가 있을 거 아닙니까?
가변적인 상태를 저장하는 것입니다.
물론 국가죠?
그리고 그게 바로 정의 게임이 난무하는 곳입니다.
하지만 그 정보를 가지고 거기에 있고 그것에 의지하고 상태를 유지하는 것이 기본적으로 그것입니다.
여기서는 정말 핑계를 대지 마세요.
문제는 클라이언트가 클라이언트에 전혀 저장된 상태가 없다는 것입니다.
전혀 서버가 아닙니다.
클라이언트는 모든 요청과 함께 상태를 전송할 책임이 있습니다.
그래서 백엔드가 충돌하는 경우를 대비해 항상 대비하고 있습니다.
원한다면, 그 상태를 기억할 필요 없이 언제든지 그 상태로 돌아갈 수 있죠.
오른쪽.
일부 상태는 메모리에 저장할 수 있고 일부 상태는 디스크에 저장할 수도 있지만 이를 잃어버려도 괜찮습니다.
사실상 거기에 어떤 것도 존재할 것이라고 믿지 마세요.
오른쪽.
예를 들어, 뭔가를 저장했는데 그것을 잃어버리고 디스크가 손상되어 다시 시작하는 경우가 있습니다.
만약 당신이 그 특정한 것에 의존한다면, 당신은 일종의 상태를 가지고 있는 셈입니다.
하지만 기술적으로 상태 저장 앱은 여전히 애플리케이션 외부의 다른 곳에 무언가를 저장할 수 있습니다.
데이터베이스 같은 거죠?
따라서 이런 방식으로 살펴보면 전체 아키텍처는 상태가 있기 때문에 상태 저장형입니다.
우리가 믿고 의지하는 매장입니다.
하지만 앱 자체는 상태가 없습니다.
왜?
앱을 중단할 수 있고 처음부터 완전히 새로운 앱을 시작할 수 있으며 해당 앱은 작동할 것입니다.
네, 다른 앱에서 읽을게요. 하지만 그건 다른 앱의 책임인 거 맞죠?
이해가 되나요?
그래서 다시 돌아가면 그 상태는 사실상 사라집니다.
사라져도 괜찮아요.
나는 아무것도 의지하지 않아요.
이 특정한 경우에 저는 완전히 무국적자입니다.
그러면 무상태 백엔드의 몇 가지 예를 살펴보겠습니다.
백엔드는 다른 곳에 데이터를 저장할 수 있나요?
그래서 우리는 그것에 대해 이야기했습니다.
응.
백엔드, 즉 무상태에 있더라도 여전히 다른 곳에 일부 데이터를 저장할 수 있습니다.
저는 그 데이터가 거기에 있어서 "이봐, 나는 그냥 통나무처럼 움직이고 있을 뿐이야"라고 말할 거라고 믿지 않습니다.
무언가를 기록하는 경우, 켜고 데이터를 가져와 해당 데이터베이스에 저장합니다.
그리고 끄고 켜도 상관없어요.
당신은 무국적자입니다.
시작할 수 있나요?
제가 항상 사람들에게 요청하는 것이 또 있습니다.
그러면 당신이 다시 무국적자가 되었는지 아닌지는 어떻게 알 수 있을까요?
여기서는 단지 뒤쪽 부분만 보고 있습니다.
바로 그 부분이에요.
여러분은 돈과 많은 서비스를 운영하는 많은 애플리케이션을 가지고 있습니다.
하지만 소유한 백엔드 애플리케이션만 살펴보면 해당 백엔드가 유휴 상태인 경우 다시 시작할 수 있습니까?
물론.
그런 다음 백업을 시작하고 클라이언트가 워크플로를 완료하기 전에 연결되었는지 확인할 수 있습니다.
마치 아무 일도 일어나지 않은 것처럼 실제로 깨지지 않고?
그렇다면 귀하의 애플리케이션은 상태 비저장입니다.
그렇지 않다면 어딘가에 당신이 그것을 잃어버렸고 고객이 있었던 주립 매장이 있을 것입니다.
그것이 거기에 있다는 것을 믿고 있습니다.
문제는 바로 여기에 있어요.
그렇다면 백엔드를 무상태로 만드는 것은 무상태 백엔드가 데이터베이스의 다른 곳에 상태를 저장할 수 있다는 것입니다.
그래서 우리는 그것에 대해 이야기했고 그들의 백엔드는 상태 비저장 상태로 남아 있지만, 시스템은 기술적으로 여전히 상태 저장 상태입니다.
오른쪽?
물론 그런 게 있을 수 있죠.
데이터베이스가 있기 때문에 전체 시스템은 상태가 유지되는 건가요?
물론, 데이터를 저장해야 하죠.
해당 데이터가 사라지면 기술적으로 저는 망가지게 됩니다.
오른쪽?
하지만 제 신청 자체는 그 자체로 요청을 처리할 수 있습니다.
무국적입니다.
해당 응용프로그램 자체에는 상태가 저장되지 않습니다.
오른쪽.
그리고 같은 일이 반복되었습니다.
유휴 시간 동안 백엔드를 다시 시작할 수 있나요?
그리고 클라이언트 워크플로는 계속 작동할 수 있습니다.
만약 당신이 그것을 할 수 있다면, 당신은 무국적 상태로 돌아가게 될 것이고 이것을 마치 그것이 그런 것처럼 생각하지 마십시오.
메달과 같아요.
그러면 "내 애플리케이션은 무상태이군요"라고 생각하게 됩니다.
괜찮아요, 그렇죠?
그것은 실제로 명예의 훈장이나 달성해야 할 무언가가 아닙니다. 그것은 단지 끝의 상태에 불과합니다.
낮.
그리고 두 가지 모두에 장단점이 있죠.
상태 유무.
오른쪽.
그리고 만약 당신이 타격을 감수할 의지가 있다면, 실제로 그걸 이룰 수 있는 몇 가지 요령을 익힐 수 있습니다.
그래서 그것은 국가적 후퇴입니다.
예를 들어, 내 사용자가 로그인 사용자라는 페이지를 방문하는 로그인 애플리케이션을 빌드했다고 가정해 보겠습니다.
그리고 비밀번호를 입력한 다음 백엔드 토크가 전환되어 Postgres 또는 데이터베이스와 통신하여 확인합니다.
사용자 이름과 비밀번호가 정확한지 확인하세요.
응답을 하면 애플리케이션이 백엔드를 생성하고 세션을 생성하며 ID는 다음과 같습니다.
세션을 종료하고 사용자를 반환합니다.
해당 세션 ID를 로컬에 저장합니다.
세션은 바로 여기에 저장됩니다.
세션은 데이터베이스에 저장되지 않고 바로 여기에 저장됩니다. 왜냐하면 제가 원하기 때문입니다.
이 경우에는 상태가 되므로, 예를 들어 프로파일에 대한 다음 호출에서 세션을 반환합니다.
안녕하세요. 프로필을 보고 싶습니다.
물론 S1의 경우에는 쿠키를 설정합니다.
쿠키는 모든 요청과 함께 S1을 전송하며, 이후의 요청은 쿠키가 전송되었기 때문입니다.
이 특정한 경우에는 세션이 존재합니다.
백엔드 윌이 하는 일은 '어라, 확인해 보자'는 것입니다.
나는 쿠키를 가져왔어요.
S1 S1은 메모리에 있나요?
제 신청서에 적혀있나요?
내 기억에 있다면 이미 이 사용자를 인증했다는 의미입니다.
저는 그가 훌륭하다는 걸 알아요.
아시다시피 모든 것은 이미 검증된 바가 있습니다.
좋아요.
그러니 이 경우에는 실제로 해당 사용자 프로필을 반환하겠습니다.
하지만 실제로 그것은 무엇을 망가뜨리는가?
문제는 여기에 있습니다.
예를 들어 그 세션에서 다시 시작했다고 가정하면 그것은 사라졌습니다.
우리는 그것을 지역적으로 저장한 적이 없습니다.
여기서 멋진 점은 세션이 유효한지 여부를 확인하기 위해 실제로 데이터베이스에 의존하지 않는다는 것입니다.
오른쪽.
그럴 수도 있었지만, 이렇게 한 이유는, 그냥 잠깐 여기를 확인하고 싶어서요.
데이터베이스로의 여행을 저장하고 싶습니다.
저는 그 여행을 하고 싶지 않아요.
지역적으로 확인하고 싶었습니다.
오른쪽.
이 특정한 경우에는 현금이 작동하는 방식입니다.
그리고 이런 경우를 생각해 봅시다.
하지만 내가 추락 사고로 인해 허리를 다시 움직였다고 가정해 보죠.
사용자가 실제로 페이지를 새로 고친 경우 해당 요청은 S-1을 전송하는 게 맞나요?
이것은 다시 보내지고 우리가 확인해 보겠습니다.
그런데 이건 거기에 없어요.
그러면 '아, 모르겠다'고 가정하게 될 겁니다.
괜찮아요?
모르겠습니다.
세션 ID가 방금 종료되었습니다.
오른쪽.
그러면 우리는 로그인을 통해 다시 응답할 것입니다.
90년대쯤에는 적어도 로그인은 했던 걸 기억하시죠.
그리고.
로그인하고 제출 버튼을 누르면 페이지 행이 로드됩니다.
괜찮은.
오른쪽.
하지만 그 순간.
프로필을 새로 고침하는 순간.
오른쪽.
다시 로그인 페이지로 돌아가게 됩니다.
때로는 효과가 있죠.
때때로 귀하의 요청이 그들이 처리하지 않은 백엔드에 도달하여 프로필 y로 돌아가는 경우가 있습니다.
왜냐하면 그것이 개발의 이유이기 때문입니다. 애플리케이션을 개발할 때, 애플리케이션을 개발할 때,
단 하나의 기계로.
그래서 당신은 이런 문제를 본 적이 없을 겁니다. 왜냐하면 당신은 항상 같은 문제에 부딪히게 될 테니까요.
오른쪽.
하지만 로드 밸런싱을 제대로 수행하는 순간, 때때로 이 서버에 접속하게 됩니다.
세션이 유효합니다.
가끔 이 서버에 접속했는데 세션이 유효하지 않아서 문제가 발생하는 경우가 있습니다.
그래서 세션이 끈적끈적한 거예요.
때로는 상태 저장 애플리케이션에 점착성이 필요합니다.
부하 분산 장치를 고정된 연결로 구성해야 하며 때로는 이것이 필요합니다.
그렇게 하면 모든 요청이 스티키 세션이나 스티키 로드 밸런싱되는 스티키한 작업을 수행할 수 있습니다.
이 클라이언트는 동일한 백엔드로 이동합니다.
때로는 이런 일을 해야 할 때도 있습니다.
사실, 게임 앱을 만들 때 레코드 수를 최소화하기 위해 그렇게 해야 했습니다.
데이터베이스에 짧은 기간 동안만 저장해두고 이런 것들을 가지고 놀 수 있게 해주세요.
그래서 이 경우 워크플로가 사용자가 망가뜨린 이유는 무엇일까요?
왜 다시 로그인을 강제로 하게 하는 건가요?
오른쪽?
그러면 무상태 백엔드로 이 문제를 어떻게 해결할까요?
당신이 하는 일은, 예, 세션을 데이터베이스에 저장해서 로그인하고 확인하는 것입니다.
발전기는 하나이지만, 그것을 켜고 S1을 데이터베이스에 저장합니다.
그래서 우리는 이것을 여기에 저장하는 중앙 집중식 시스템을 가지고 있고 이제 이것을 반환할 것입니다.
하나.
클라이언트가 새로 고침되지만, 아무것도 저장하지 않을 때마다 원하면 저장할 수 있지 않나요?
지역적으로는 귀하의 선택에 달려 있습니다.
하지만 백엔드에서는 항상 데이터베이스를 확인합니다.
야, 이거 유효한 거야?
오른쪽?
이거 하나예요라고 적혀 있어요.
네, 유효합니다.
유효하다면 들어가서 '응, 좋다'고 말하세요.
계속해서 진행하세요.
오른쪽.
유효하지 않다면 실패하게 될 것입니다.
오른쪽.
그렇다면 세션은 실제로 어딘가에 영구적으로 저장되어 있는 건가요?
이것이 Postgres인지 여부는 당신이 책임을 제거했기 때문에 맞습니다.
여러 개의 백엔드를 구축하면 앱이 작동할 것입니다.
따라서 해당 사용자 프로필이 다른 백엔드로 이동한 경우 해당 백엔드가 여전히 해당 백엔드와 통신하기 때문에 작동합니다.
데이터베이스죠?
따라서 전체 시스템은 여전히 상태가 유지됩니다. 왜냐하면 우리가 멈추고 데이터베이스에 상태를 저장하고 있기 때문입니다.
하지만 무국적은 백엔드 애플리케이션 자체의 속성입니다.
그걸 파괴할 수도 있고, 내 애플리케이션을 죽일 수도 있고, 다시 시작해서 다른 애플리케이션을 실행할 수도 있어요.
물론입니다.
바로 여기에 요령이 있습니다.
물론 이에 대해 논쟁할 수도 있고, 실제로 백엔드는 여전히 상태 유지 상태라고 말할 수도 있습니다.
다른 곳에 저장하기 때문이죠.
오른쪽.
상태 저장 및 상태 비저장을 기술적으로 어떻게 정의하는지에 대한 질문으로 돌아갑니다.
이 예에서 데이터베이스가 죽으면 전체 시스템은 무의미해집니다.
오른쪽?
오른쪽.
하지만 백엔드, 심지어 백엔드조차도 당신에게 응답할 수 없습니다. 왜냐하면 그들은 당신에게 무언가가 있다는 것을 알고 있기 때문입니다.
그것에 의존하는 정보.
오른쪽.
따라서 상태 저장 프로토콜과 상태 비저장 프로토콜입니다.
이제 우리는 프로토콜 자체, 즉 클라이언트에서 서로 대화하는 방식에 대해 이야기하고 있습니다.
서버.
오른쪽.
따라서 프로토콜은 실제로 상태를 저장하거나 저장하지 않거나 어떤 상태에도 의존하지 않도록 설계될 수 있습니다.
또한.
여기서도 아주 좋은 예가 있습니다.
예를 들어, TCP는 확실히 상태가 있습니다.
왜?
왜냐하면 그런 것이 있기 때문이다.
클라이언트와 서버 모두에 클라이언트와 서버 위에 저장된 정보입니다.
순서가 있습니다.
귀하가 보내는 모든 세그먼트에는 시퀀스가 레이블되어 있으며 시퀀스는 실제로 저장됩니다.
상태.
문자 그대로 "아, 연결이 이제 닫혔습니다."라고 말하는 상태 다이어그램이 있습니다.
이제 연결이 열렸습니다.
이제 연결이 설정되었습니다.
이제 연결이 대기 중입니다.
국가가 존재합니다.
상태 머신은 여기와 서버 측에 있습니다.
오른쪽.
그리고 그들은 시퀀스에 대한 연결을 유지하고 창 크기를 유지합니다.
흐름 제어, 혼잡 제어, 혼잡 제어 창.
이 모든 것은 국가 정보입니다.
이것들이 사라지면 이 연결은 아무 의미가 없고, 쓸모가 없습니다.
바로 그 자리에서 연결을 끊어버리면 그 이후로는 계속 진행하는 게 무의미해집니다.
이러한 매개변수 중 하나라도 손실되면 연결을 재설정합니다. 사실상 그게 전부입니다.
TCP가 상태를 저장하는 이유
오른쪽.
그래서 우리는 연결 파일 기술자 시퀀스에 대해 이야기했습니다.
반면, UDP는 실제로 완전히 무상태입니다.
이것은 메시지 기반이지만 아무것도 저장하지 않습니다.
또는 파일 설명자가 있는 것처럼 저장을 하더라도 실제로는 거기에 있을 필요는 없습니다.
오른쪽?
여러 데이터그램을 효과적으로 보내고 이 데이터그램을 여러 서버에서 수신할 수 있습니다.
괜찮아요.
완전히 무국적입니다.
예를 들어 DNS를 살펴보죠.
DNS 자체는 상태 비저장 프로토콜입니다.
왜?
DNS 쿼리가 포함된 UDP 데이터그램을 보낼 때는 연결에서 보내지 않기 때문입니다.
UDP이고 연결이 적고 연결이 없습니다.
간단히 "안녕하세요, 이 IP 주소로 접속하겠습니다"라고 말하면 됩니다.
오른쪽?
여기가 목적지 항구 맞죠?
그리고 로컬 포트를 생성하고 IP 주소를 생성하고 이렇게 말합니다.
가다.
우리가 TCP에서 응답했는지 어떻게 알 수 있나요?
우리는 연결되어 있어요.
이 연결에서 오는 모든 것은 내가 아마도 무언가를 보냈고 지금 그것이 들어오고 있다는 것을 의미합니다.
이 연결, 이 연결을 읽어보세요.
UDP 연결이 없습니다.
따라서 UDP 패킷이 있는 경우 무엇이 무엇인지 찾아내는 것은 사용자의 책임입니다.
그래서 DNS는 실제로 모든 대화에 대해 쿼리 ID를 추가합니다.
따라서 DNS 쿼리를 보낼 경우 쿼리 ID와 응답을 첨부하면 DNS 서버는
한번 답장해 보세요. "안녕하세요, Google.com은 실제로 이 IP 주소입니다."
여기에 실제로 호출자 ID를 포트로 다시 반환하는 쿼리 ID가 있습니다.
보냈습니다.
이제 이 경우 쿼리 아이디어가 다시 나타나고 이 경우 UDP 클라이언트가 해당 정보를 읽습니다.
그리고 효과적으로 리눅스가 되고, 운영체제는 대상 포트를 기준으로 매핑할 것입니다.
아마도 다시 응용 프로그램으로 돌아가야 할 것 같습니다.
이제 이 경우에 애플리케이션이 실제로 죽는다면, 맞다고 주장할 수 있습니다.
실제로 애플리케이션이 종료되는 경우.
그러면 없습니다.
응답해야 할 것이 하나 있습니다.
이를 받아들이려면 대상 포트가 운영 체제에 존재하지 않기 때문에 해당 드래곤을 사용해야 합니다.
따라서 DNS 클라이언트 서버는 상태가 있지만 프로토콜은 다음과 같다고 주장할 수 있습니다.
UDP는 상태가 없습니다.
나는 상관하지 않아.
당신이 연결을 끊은 건 당신의 잘못이에요.
오른쪽.
이걸 얘기하는 건 정말 위험한 짓이에요.
그래서 저는 이 문제를 아주 사소한 방식으로 이야기하는 것을 좋아하지 않습니다.
나는 그것을 언급하고 그것에 대해 배우고 싶고 다시는 그것을 가지고 가지 않기를 원합니다.
소금 한 알 정도.
이런 것들은 논의하기 매우 어려운 것들입니다.
빨리, 같은 것을 해.
이는 1초 안에 좀 더 자세히 설명하겠습니다.
Quick은 실제로 매우 유사합니다. Quick은 연결을 식별하기 위해 연결 ID를 보내지만 quick은
TCP처럼 작동하기 때문에 모든 종류의 상태가 있기 때문에 실제로는 상태 저장형이지만
상태 비저장 UDP는 모든 UDP 패킷과 함께 항상 동일한 연결 ID를 보내야 합니다.
그래서 우리가 이야기하는 것은 모두 이 특정한 연결에 관한 것이라는 걸 알고 있습니다.
따라서 우리는 프로토콜 자체를 통해 상태를 효과적으로 전송하고 있는데, 이는 상태가 없습니다.
그리고 또 다른 점은 약간의 반전이 있다는 것입니다.
상태 저장 프로토콜 위에 상태 없는 프로토콜을 구축할 수 있으며, 그 반대의 경우도 마찬가지입니다.
오른쪽.
HTTP가 상태인 것처럼 HTTP는 요청-응답이기 때문에 상태가 없습니다.
요청을 보낼 수 있죠.
그리고 서버로 가서 요청을 하면 응답을 받게 됩니다.
서버가 죽고 다른 서버가 돌아오면 다음 요청이 실패할 것이므로 신경 쓰지 마세요.
필요한 모든 것이 갖춰져 있습니다.
이 쿠키는 자신을 식별하기 위해 사용됩니다.
그러니까 쿠키가 필요한 거 아니겠어요?
HTTP를 사용하면 쿠키가 효과적으로 상태를 전송하고 상태를 기억하거나 기억합니다.
우리를.
그리고 TCP 기반으로 구축되어 상태 비저장입니다.
그러면 TCP 연결이 끊어지면 어떻게 되나요?
오른쪽.
괜찮은.
그는 무작정 또 다른 것을 만들었나요?
누가 신경 쓰겠어?
오른쪽.
이는 전달의 매개체입니다.
그들은 TCP 연결이 항상 존재하여 끊어지거나 새로운 연결을 생성할 것이라고 의존하지 않습니다.
우리는 브라우저에서 이를 보았습니다.
예를 들어, Quick은 UDP 기반으로 구축된 상태 저장 프로토콜입니다.
오른쪽.
같은 것.
그러면 여기서 완전히 무국적 시스템이란 무엇인가?
생각해 보면, 시스템 시스템은 정말 드물죠.
당신이라고 가정해 보죠.
이 경우에는 모든 요청과 백엔드에 상태를 포함시켜야 합니다.
다음은 백엔드 서비스가 완전히 의존하는 상태 비저장 요청의 예입니다.
입력을 완전히 입력하는 것은 기본적으로 입력 그 자체입니다.
입력 자체에 필요한 모든 것이 들어있습니다.
심지어 다른 서비스와 통신할 필요도 없습니다.
따라서 예를 들어, 이 시스템에만 의존한다면 전체 시스템은 무상태가 됩니다.
오른쪽.
어떤 숫자가 소수인지 아닌지 확인하는 앱을 만든다고 가정해 보죠.
그건 완전히 국가가 없는 시스템이에요.
오른쪽.
요청을 보내면 이를 만드는 데이터베이스에 소수를 저장할 수 있다고 가정합니다.
일종의 상태 저장형 시스템입니다.
하지만 이 경우에는 그냥 반복해서 살펴보면, 이건 실제로 중요한 움직임이라고 할 수 있습니다.
JSON 웹 토큰에서 JWT는 실제로 완전히 상태 없는 시스템입니다.
사실, 제가 YouTube 채널에서 그에 대해 이야기했을 때는 그랬습니다.
제이슨 제이슨 웹 토큰은 실제로 그렇게 안전하지 않습니다.
그 자체로는 상태가 없기 때문에 모든 것이 토큰에 있습니다.
그것은 장점이자 단점이 동시에 있는 셈이죠.
왜냐하면 모든 것이 이 토큰에 들어 있다면 누군가가 이것을 훔쳤고 이것을 다음과 같이 표시하려고 한다면 어떻게 될까요?
유효하지 않은?
이것.
이 토큰은 좋지 않습니다.
누군가가 그런 신분증으로 그것을 훔쳤을 겁니다.
간단하죠.
데이터베이스로 가서 이를 무효로 바꾸세요.
실제로 검증을 시도하는 다음 사람은 데이터베이스를 쿼리하고 "잠깐만요"라고 말할 것입니다.
1분 전, 세션이 취소되었습니다.
뭐하세요?
그리고.
하지만 제이슨은 말하고 있었습니다.
다른 서버와 대화하는 것이 아닙니다.
그러니 이 정도 대화라면 길었을 겁니다.
오른쪽.
그러면 이 토큰을 훔친 사람은 영원히 토큰을 잃게 되거나 그 유효성이 어떻게 되든 상관없습니다.
그것이 도난당한 것을 발견했습니다.
누군가가 그것을 나쁜 짓을 하는 데에 사용할 수도 있었어요.
오른쪽?
어쨌든 문제죠.
하지만 JWT보다 세션을 더 많이 제어할 수 있습니다.
그래서 JWT에는 새로 고침 토큰이라는 개념이 있는 거예요.
새로 고침 토큰과 액세스 토큰을 개발한 다음 액세스 토큰을 최대한 짧게 만드는 방법
가능한.
새로 고침 토큰을 더 길게 만듭니다.
하지만 똑같은 문제가 일어났죠?
무엇이든.
그리고 누군가가 새로 고침 토큰을 훔쳐서 그것이 이것인 경우는 어떻게 되나요?
그렇기 때문에 시스템에 TLS를 적용해 모든 것을 암호화해야 합니다.
가능한 한 섬세하게 대처하려고 노력하세요.
그런데, 여러분은 엔지니어링 분야에서 모든 것이 다 파악되었다고 생각하지 않나요?
아직 모든 것이 다 밝혀지지 않은 것 같아요.
많은 엔지니어가 모든 것을 알고 있다는 듯이 말하지만, 사실은 모든 것을 알고 있는 것은 아닙니다.
현재의 엔지니어링 방식에는 허점이 참 많죠.
그 이유는?
그 이유는 사람들은 문제가 발생했을 때만 이야기하기 때문입니다.
이 구멍에 대해 아는 사람들이 있습니다.
그렇지 않은 사람도 있죠.
그래서 저는.
저는 이야기할 때 제가 현재 가지고 있는 지식에 기반하여 이야기하려고 노력합니다.
하지만 기억하세요.
무슨 일이든 일어날 수 있고, 나쁜 일도 일어날 수 있고, 모든 것에는 결함이 있습니다.
그리고 우리는 그 시스템을 이해하려고 노력합니다.
그것이 목표예요.
그리고 적어도 나에게는 나 자신에게 말하고 있는 것 같아요. 더 나은 소프트웨어 엔지니어가 되기 위해 정말 노력하고 있어요.
백엔드 엔지니어는 현재 우리가 가지고 있는 것과 이것의 현재 한계를 이해하고 있습니다.
그리고 이런 한계를 안다면, 그 한계를 벗어나서 일을 할 수 있고, 그것이 지금으로서는 최선입니다.
내일은 또 다른 일이 일어날지도 몰라요.
그리고 저는 항상 이 정의는 아무 데도 가지 않을 것이라고 덧붙이는데, 이 정의도 역시 회의적으로 받아들이시기 바랍니다.
여러분, 이게 상태 저장형 아키텍처와 상태 비저장형 아키텍처에 대한 세션이었습니다.
대개 마지막 강의예요.
