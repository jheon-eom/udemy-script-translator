인터넷 프로토콜, 혹은 제가 부르고 싶은 대로 인터넷의 매개체입니다.

아시다시피, 여러분은 무엇을 하든 간에요.

클라이언트에서 백엔드로 요청을 보내거나 백엔드에서 응답을 받으면 모든 프로토콜

결국, 관계없이, 프로토콜은 데이터가 결국 어떤 것으로 불리는 곳에 저장될 것입니다.

IP 패킷.

목적지는 목적지의 IP 주소이고, 출발지는 출발지입니다.

그 계층에서는 포트에 대해 아무것도 알 수 없습니다.

우리는 헤더, HDTV 헤더, 암호화에 대해 아무것도 모릅니다.

일은, '이봐, 여기에 데이터가 있어' 입니다.

데이터는 암호화될 수 있으며, gRPC가 될 수도 있고, UDP가 될 수도 있으며, TCP IP가 될 수도 있습니다.

후속작에 대한 크리스의 응답이 될 수도 있겠습니다.

모두 IP 패킷에 맞습니다.

그래서 이것이 이 강의의 주제입니다.

따라서 이 강의는 기본적으로 내 네트워킹 과정의 강의 모음을 가져와 결합한 것입니다.

네 사람이 쉽게 이해할 수 있도록 하나의 강의로 정리했습니다.

사실, 여러분이 즐기셨으면 좋겠습니다.

시작해 볼까요.

IP 빌딩 블록을 이렇게 명명한 이유는 이것이 기본적인 빌딩 블록이라고 생각했기 때문입니다.

IP 프로토콜을 이해하려면 이해가 필요합니다.

알다시피, 가능한 한 이 문제를 명확하게 설명하려고 노력했습니다.

실제로 패킷을 작성했을 때 무슨 일이 일어났나요?

내가 그것을 다시 보냈을 때 무슨 일이 일어났고 지금 여기서 패킷이라는 단어를 언급하고 있는데, 여러분, 나는 당신을 원합니다.

패킷이 무엇인지 생각해보면 세 번째 계층이 있습니다.

패킷이 3계층이라고 말할 때, 그것은 목적지, IP 주소가 포함된 데이터 묶음을 의미합니다.

소스 IP 주소를 포함하면 다른 헤더는 모두 그렇습니다.

하지만 우리는 지금 신경 쓰지 않습니다.

오른쪽.

하지만 그게 다예요.

항구는 상관없어.

포트.

응.

IP 패킷 안에는 포트가 있고, JSON, 데이터, http 등 모든 것이 들어있습니다.

하지만 라우터에게는 그것은 단지 IP 패킷일 뿐입니다.

그리고 그것이 이 모든 것의 아름다움이라고 생각합니다. 생각해보면, 뛰어들어 봅시다.

그것으로.

IP 주소는 3계층 속성입니다.

우리는 이것에 대해 이야기했습니다.

자동으로 설정하거나 정적으로 정적으로 설정할 수 있습니다.

오른쪽.

이게 바로 DHCP예요.

제가 이야기 하겠지만, 아이디어는 IP 주소를 할당할 수 있다는 것입니다.

아시다시피, 이것은 네트워크 엔지니어링 과정, 실제 과정 세부 정보 ID가 가치 있는 대화가 될 곳입니다.

알겠어요. DHCP는 어떻게 작동하고, 할당은 어떻게 되나요?

이건 네트워크 수준의 것이에요. 네트워킹, 네트워크 엔지니어링 같은 거죠.

알다시피, 좀 더 자세한 내용이기 때문에 그 정도까지는 다루지 않겠습니다.

IP 주소가 있으니 괜찮습니다.

네트워크 문제를 해결하지 않아요.

아시다시피, 그 특정 분야에 정통하고 능숙한 네트워크 엔지니어가 있습니다.

아시다시피, 문제 해결과 IP DHCP가 어떻게 작동하는지, 그리고 그것이 프로토콜인지에 대한 것입니다.

그러니 좋습니다. 어쩌면 나중에 마음을 바꿔서 이에 대한 강의를 추가할 수도 있을 겁니다.

누가 알겠나?

하지만 IP 주소는 자동으로 할당될 수도 있고, 컴퓨터에 정적으로 고정할 수도 있습니다.

아니요, 그렇습니다.

이것에 대해서 이야기하겠습니다.

네트워크 포트와 호스트 부분이 있습니다.

IP 주소는 4바이트이고 v4가 되며 IPV6보다 큽니다.

이 강좌에서는 IPV 6에 대해 이야기하겠습니다.

아마 나중에 더 추가할 수도 있을 것 같아요.

조금만 더 낮게 유지하자, 맞죠?

현재 콘텐츠가 너무 많기 때문에 앞으로 더 많은 콘텐츠를 추가할 예정입니다.

하지만 그렇죠, 조금은 그렇죠?

그리고 두 개가 있어요.

부분, A, B, C, D 또는 A, B, c, D는 첫 번째, 두 번째, 세 번째, 네 번째입니다.

X로 바꿔요.

그리고 슬래시 x를 이해해주시길 바라죠?

여기의 x는 네트워크 비트이고 나머지는 호스트입니다.

여기에 한 가지 예가 있습니다.

만약 내가 12192168.254.0 / 24라고 하면,

즉, 첫 번째 24비트는 888이고, 이는 24입니다.

이 강아지들은 네트워크 부분입니다.

그리고 이 왼쪽 바이트는 그대로이고, 이 경우 네 번째 바이트가 호스트입니다.

그 말은 최대 2개, 5개, 3개, 5개의 호스트를 가질 수 있다는 뜻이에요.

글쎄요, 최대 424개 네트워크를 가질 수 있죠.

첫 24비트 중 3바이트는 네트워크이고 나머지 8바이트는 호스트입니다.

이것에 대해서만 이야기하세요.

즉, 원하는 코스를 최대 24배까지 살펴볼 수 있다는 뜻입니다.

정말 이렇게 많은 네트워크가 필요한가요?

자신이 네트워크 관리자인지 다시 한 번 자문해보세요.

그것이 당신의 직업의 한 부분이에요.

이런 일은 우리가 보통 하는 일이 아닙니다.

애플리케이션을 빌드하려면 패킷이 어떻게 전달되는지 이해해야 합니다.

그러나 네트워크 구성은 실제로 네트워크 엔지니어에게 맡기는 것이 더 좋습니다.

그들이 말했듯이, 빵과 버터죠.

오른쪽?

네트워크가 몇 개나 필요한가요?

아, 슬래시 24가 필요한가요?

좀 지나치죠?

제가 그것을 좀 줄여서 설명하겠습니다.

실제로 네트워크보다 호스트가 더 필요합니다.

그걸로 놀 수도 있죠.

이것은 그 자체로 하나의 와드입니다.

그래서 제가 이 과정이 일반적으로 심층 네트워크를 위한 것이라고 언급한 이유는 가르치지 않을 것이기 때문입니다.

이런 저수준의 것들을 다 배우고, CCNA를 공부하고, 이런 모든 시험에 합격하는 걸 아는 거죠.

아니요. 사실 이건 네트워크를 이해하고자 하는 소프트웨어 엔지니어를 위해 설계된 것입니다.

그것은 다리예요.

그 후에 네트워킹에 정말 관심이 있다면 실제 네트워킹 코스를 수강할 수도 있습니다.

그리고 당신이 원한다면 실제로 더 나은, 더 나은 행운을 얻을 수도 있습니다. 생각해 보세요.

그렇죠. 이제 높은 수준의 내용을 이해할 수 있게 됐거든요.

각 네트워크에는 2~55개의 호스트가 있습니다.

이것을 서브넷이라고도 부릅니다.

서브넷 마스크라는 매우 중요한 개념 때문에 이 서브넷에 대해 들어보신 적이 있나요?

따라서 19216 8 대 2 54 대 0 24를 하면 이것을 서브넷이라고도 하며 서브넷에는 서브넷이 있어야 합니다.

마스크.

따라서 서브넷 마스크가 사용되고 IP 패킷을 보내는 경우 IP 주소가 있는 것을 알 수 있습니다.

그리고 당신은 내 서브넷에 속하도록 보내려는 IP 주소가 무엇인지 알고 싶어합니다.

그 특정 질문에 대답하세요. 그 질문이 그렇게 될 것이기 때문입니다.

두 가지 논리로 나뉩니다.

내 서브넷에 속해 있으면 이렇게 하고, 내 할당에 속해 있지 않으면 제대로 하면 됩니다.

내 서브넷에 있는 경우 MAC 주소를 사용해서 호스트 간 통신으로 직접 다시 보낼 수 있습니다.

그냥 MAC 주소를 사용해서 직접 보내면 되는데 문자 그대로 여러분이 아는 것과 같은 네트워크에 있으니까요.

서브넷에 없으면 아무 의미가 없습니다.

이를 라우팅하는 방법을 아는 사람과 상담해야 하며 일반적으로 이를 라우터라고 합니다.

또는 관문.

그렇기 때문에 게이트웨이 IP 주소가 있는 것입니다.

할당한 모든 네트워크에는 게이트웨이 IP 주소가 있습니다.

그 때는 상황이 불분명하죠.

아, 내가 모르는 게 뭐지?

게이트웨이로 보내세요.

이런 혼란 중 일부는 IP가 같은 서브넷에 있는지 여부를 확인하는 데 사용됩니다.

기본 게이트웨이.

우리는 기본 게이트웨이에 대해서만 이야기합니다.

대부분의 네트워크는 호스트와 기본 게이트웨이로 구성됩니다.

그래서 네트워크가 있고 그 네트워크 내에 호스트가 베팅하는 대로 호스트가 여러 개 있습니다.

당신은 해당 네트워크를 가질 수 있습니다.

그리고 호스트 중 하나는 게이트웨이여야 합니다.

왜?

해당 호스트는 서브넷 외부의 무언가와 통신을 원하기 때문입니다.

그들은 관문과 대화해야 합니다.

게이트웨이는 두 개의 네트워크 인터페이스가 있는 또 다른 장치일 뿐입니다. 하나는 네트워크이고

이 네트워크에 속하도록 할당되고 다른 네트워크에 속하는 다른 네트워크, 또는 아마도 세 개

아니면 4개, 5개, 6개.

이러한 국경 라우터에는 수백 개의 네트워크가 있습니다.

아시다시피, 그들은 다른 많은 네트워크와도 소통할 수 있죠.

호스트 B와 호스트 B가 같은 네트워크에 있다면 실제로 호스트 B와 직접 통신할 수 있습니다.

서브넷을 효과적으로 사용하고 MAC 주소를 거기에 사용하죠?

그렇지 않으면 a가 B와 통신하는 방법을 모르는 경우 B가 서브넷에 없고 다음을 통해 알아낼 수 있습니다.

서브넷 마스크를 사용해 예를 들어보겠습니다.

괜찮아요.

아니 잠깐만요.

그렇지 않으면 게이트웨이를 알고 있을 수 있는 사람에게 보냅니다.

그런데, 관문에서는 모를 수도 있어요.

오른쪽.

결국 게이트웨이는 그것을 아는 다른 게이트웨이와 통신할 수도 있기 때문입니다.

그렇죠, 요점은 이해하시죠?

우아한 디자인이네요.

정말 좋아요.

게이트웨이에는 각각의 IP 주소가 있고, 각 호스트는 게이트웨이를 알고 있어야 하지 않나요?

또한 통신하는 네트워크의 수에 따라 여러 개의 IP 주소를 갖습니다.

이봐요, 예를 하나 찾아봐요. 그러면 내가 여기서 사라져서 전체적인 그림을 보여드릴게요.

좋습니다. 호스트는 192168.123입니다.

19216821과 통화하고 싶어요. 두 두 명과 통화해야 해요.

여기서는 '말하다'라는 단어를 사용했습니다.

제가 말하는 것은 문자 그대로 데이터를 보내고, 패킷을 보내서 애플리케이션 클라이언트로 변환하는 것입니다.

프런트엔드, 백엔드 이야기.

예를 들어 HTTP 요청을 보냅니다.

이게 대화라는 걸 알죠?

.1.2가 실제로 서버이고 one, two, three가 이 경우 실제로 클라이언트라고 가정합니다.

curl 요청을 보내거나 SSH 서버를 사용하고 싶습니다.

대화의 진짜 의미는 바로 그것입니다.

결국 내가 말했든 말든 HTTP, DNS, 이 모든 것이 잘 들어맞는 IP에 들어맞습니다.

대상 IP와 소스 IP가 있는 패킷.

그리고 그것이 바로 이것의 매력이죠.

라우터는 프로토콜에 관심이 없습니다.

다행히도 일부 라우터는 그렇습니다.

그들은 콘텐츠를 보고 특정 프로토콜을 차단하지만 대부분은 그렇지 않습니다.

하지만 192168.1231을 살펴보죠.

1:2로 대화하다.

첫 번째 질문은 Are you and my subnet?에 대한 답을 시도합니다.

자체와 대상 IP 주소에 서브넷 마스크를 적용합니다.

서브넷 마스크는 무엇입니까?

자체 서브넷 마스크입니다.

오른쪽.

그것이 가진 유일한 것이니까요.

다른 기계에서는 다룰 수 없는 주제입니다.

실제로 필요한 것은 아니고 여러분이 가지고 있는 서브넷 마스크가 필요합니다.

오른쪽.

네트워크에 접속하면 IP 주소, 서브넷 마스크 등 세 가지 정보를 얻을 수 있습니다.

그리고 당신의 관문.

이것들이 없다면 아무것도 할 수 없습니다.

당신은 사실상 물속에서 죽은 셈이에요.

누구와도 소통할 수 없잖아요?

이 세 가지가 필요합니다.

그러니까 이 사람을 데리고 255255255.0을 실행하세요.

정상적인 연산자를 사용하면 이것이 모두 1이고 2이고 1인 것을 알 수 있습니다.

다섯.

1은 5개입니다.

오른쪽.

그리고 이게 0, 1이고, 그 다음 무엇이든 1이고, 무엇이든 1로 끝내면 같은 값이 됩니다.

그러니까 이런 비트를 추가하면, 그렇죠. 이건 간단한 바이트 연산이에요.

무엇이든 1로 끝나면 같은 값이 되죠?

따라서 192는 192168로 유지되고 255는 9로 됩니다.

결국 이것들은 하나이기 때문입니다.

여러분을 위해 비트맵을 만들었으면 좋았을 텐데, 여러분은 무슨 뜻인지 아실 겁니다. 111111.

그리고 이것들은 1 0 같은 실제 비트입니다.

오른쪽.

그러니까 뭐든지요.

당신과 5는 같은 값이 될 것입니다. 5와 1이 하나가 될 것입니다.

그리고 가장 중요한 것은, 0, 그리고 무엇이든 0이라는 것입니다.

0을 무엇이든 추가하면, 그것은 단지 0이 됩니다.

오른쪽?

그러니까 0과 3은 0이에요.

괜찮은.

두 번째 IP 주소 2와 Z2에 적용해 보면 0은 0입니다.

그리고 이것이 이것의 출력입니다.

두 번째 IP 주소의 출력은 4192168101920601110입니다.

이것들은 동일한 서브넷이며 그 질문은 우리가 이야기했던 첫 번째 분기로 이어집니다.

루팅이 필요합니다.

루팅할 필요가 없습니다.

난 당신들이 필요 없어.

저는 이 사람이 필요 없어요.

사실, 그것은 스위치이기 때문에 그렇습니다.

이 경우에는 스위치로 플레이하는 것입니다.

잠깐 이야기해 보겠습니다.

그래서 이 데이터를 라우터로 보내고 있는데, 라우터는 2계층으로만 올라가고 있어요.

이 경우에는 IP 주소가 필요하지 않습니다.

하지만 왜 그럴까?

같은 서브넷이 아니기 때문이겠죠?

라우터가 계층으로 이동하여 IP 주소를 확인할 수도 있지만 동일한 IP인 것 같습니다.

주소.

오른쪽.

그래서 이 경우에는 MAC 주소만 보게 될 것입니다.

괜찮습니다.

이 MAC 주소는 실제로 이 포트 붐에 있어요.

바로 여기로 보내죠.

따라서 이 경우 라우터는 스위치 역할을 합니다.

그러니 정말 깔끔하게 보이도록 하겠습니다.

이 특별한 케이스에는 두 번째 레이어만 있으면 됩니다.

그런데 이게 두 번째 네트워크예요.

우리는 그 점에 대해 이야기할 것입니다.

좋습니다. 조금 더 흥미진진하게 만들어 보겠습니다.

19222168.1.3.

192221682와 통화하고 싶어요, 2, 2.

이 남자, 이 남자가 이 남자와 이야기하고 싶어해요.

음, 다른 네트워크죠?

내가 어떻게 알았지?

글쎄요, 마스크를 바르면 갑자기 이게 192160120이라는 걸 알게 되죠.

나, 나는 하나, 둘, 셋이었어요.

나.

내 말이 맞나요?

이것이 제 네트워크입니다.

제가 통화하고 싶은 사람은 2 대 0 다른 서브넷입니다.

어떻게 해야 할지 모르겠어요.

이것은 다른 서브넷입니다.

그걸 담당하는 사람에게 전달해야 해요.

패킷은 기본 게이트웨이로 전송됩니다.

내 기본 게이트웨이는 192168 1.100입니다.

이제 패킷을 라우터로 보내야 하는데, 무엇이 필요한지 추측해보세요.

이제 첫 번째 시나리오로 돌아갑니다.

말에서 말에게 직접 보내는 거예요.

이제 당신은 마치 그 사람에게 직접 소포를 보내는 것과 같습니다.

하지만 Mac 주소는 바로 라우터의 주소입니다.

그리고 여기서 가능한 모든 공격이 일어납니다.

이것을 우리의 중독이라고 합니다.

만약 여기서 누군가가 라우터 역할을 맡는다면 모든 패킷이 그곳을 통과할 수 있을 겁니다.

그리고 그렇게 해서 우리는 중독되었습니다.

그건 또 다른 주제로 이야기하겠습니다.

오른쪽.

Mac 주소는 라우터의 Mac 주소가 무엇인지 알아야 하기 때문에 지금 필요합니다.

패킷을 라우터로 보내려고 합니다.

오른쪽.

그리고 내 라우터는 나와 같은 서브넷에 있어요.

이걸 라우터에 보내니까 라우터가 돌아서서 'OC님, 이 사람은 어디 있는 거지?'라고 묻더군요.

192.

따라서 라우터는 실제로 반대편에 또 다른 IP 주소를 가지고 있습니다.

1921682 200.

오른쪽.

그래서 라우터는 두 배로 살아요. 아시다시피 두 번 살아요.

아시죠, 그게 바로 그 일이에요. 효과적으로 두 가지 삶을 사는 거죠.

여기가 주소이고 여기가 주소예요.

그러니까 살아 있다는 것은 실제로 두 가지 표현이 있다는 거예요.

그래서 이건 이런 종류의 주소로 통신할 수 있어요.

그리고 기본적으로 이렇게 진행됩니다.

좋습니다. 요약해 보겠습니다.

이제 IP 주소에 대해 이야기해 보겠습니다.

네트워크 부분과 호스트 부분의 차이점은 무엇인가요?

그리고 원한다면 현재 네트워크가 어떤지 알 수 있고 가능한 호스트 수를 알 수 있습니다.

발생하며 라우터를 구성하여 더 많거나 적은 호스트를 할당할 수 있습니다.

오른쪽.

그것을 기반으로 우리는 서브넷에 대해 이야기하고 서브넷 마스크에 대해 이야기합니다. 매우 매우 중요한 개념입니다.

이해하다.

이것이 왜 중요한지, 그리고 마지막 섹션에서 실제로 어디에 있는지에 대해 더 자세히 이야기하겠습니다.

데이터베이스가 실제로 다른 서브넷에 있는 경우 애플리케이션으로 돌아가고 IP 패킷이

백엔드 애플리케이션에서 데이터베이스로의 TCP 연결 요청 형식입니다.

라우터.

그리고 라우터가 혼잡하면 지연이 발생합니다.

그러니 이건 그 섹션에 대한 약간의 호기심을 자극하는 스포일러 경고입니다.

하지만 그게 말이 되는 것 중 하나예요.

데이터베이스를 다른 서브넷에 두지 마세요.

솔직히 말해서, 때로는 그렇게 나쁘지 않은 경우도 있습니다.

다른 서브넷에 넣어도 괜찮습니다.

하지만 이 라우터가 너무 혼잡하고 수천 개의 네트워크와 통신한다면 어떻게 될까요?

오른쪽.

또는 너무 많은 네트워크와 너무 많은 호스트가 패킷을 라우팅하는 경우 다음과 같은 기회가 있을 수 있습니다.

라우터는 버퍼를 채우고 아름다운 SQL 문 요청을 전송합니다.

여러 세그먼트는 라우터에 배치되며 몇 밀리초가 지나야 데이터베이스에 도달합니다.

나중에 그 지연을 보게 될 거예요.

백엔드 애플리케이션에서 지연이 발생하는 이유를 아는 사람이 있나요?

그건 정말 작은 것, 아주 작은 것이에요.

그리고 당신은 즉시 그것을 이해할 수 있습니다. 왜냐하면 이제 그들은 실제로 무슨 일이 일어나고 있는지 이해했기 때문입니다.

이제 뒷면과 구성을 확인하세요.

귀하의 데이터베이스와 귀하의 애플리케이션이 다릅니까?

서브넷을 넣으면 비용이 들지 않습니다.

오른쪽.

이 경우에는 스위치를 켜세요.

실제 스위치를 넣어보세요.

실제로 네트워크 구성이 그림에 등장하는 곳은 바로 여기입니다.

실제 네트워크 스위치를 넣고 고성능 네트워크 스위치를 넣고 데이터베이스를 넣는 것과 같습니다.

그리고 신청서.

이 스위치와 대화하세요.

해당 애플리케이션은 라우터와 통신할 권한이 없습니다. 맞나요?

스위치로 애플리케이션 패킷을 라우팅하는 데 라우터를 사용하지 마세요.

아시다시피, 이쪽에서는 그냥 값싼 스위치일 뿐이에요.

오른쪽.

라우터는 스위치로 설계되지 않았기 때문에 고성능 스위치의 가격은 다음과 같습니다.

많은 돈이 드는 기업용 스위치.

다시 말씀드리지만, 저는 이 분야에 대해 잘 모르지만 정말 그 수준에 도달하고 싶다면 그것은 네트워크입니다.

공학이 밥줄인 줄 알죠.

그리고 그것이 제가 원하는 것입니다.

저는 그 격차를 메우고 싶습니다.

제가 말하려는 건 바로 이거예요, 여러분.

다시 그 순간으로 돌아가서.

당신은 이것을 이해합니다.

당신은 무엇을 해야 할지 전혀 모르기 때문에 네트워크 엔지니어에게 이 구성을 대신 해달라고 요청할 것입니다.

원하지?

그들은 모든 것을 알지만, 여러분이 원하는 것이 무엇인지 모르잖아요?

그러니 네트워크 엔지니어라면 과정에 대해 이야기해야 합니다.

감사합니다.

하지만 이제 요구 사항을 이해하셨나요?

하지만 이제 우리는 그 격차를 메우고 있습니다.

그들이 말했듯이, 우리는 상처를 닫고 있는 셈이죠.

하지만 그렇습니다. 기본 게이트웨이, 기본 게이트웨이 개념도 설명되어 있습니다.

이 강의.

IP 패킷의 첫 번째 강의에 이어서 다음 강의로 넘어가는 건 어떨까요?

하비, 아시다시피, 여기서 논의할 게 너무 많아요.

시작해 볼까요.

이제 인터넷 프로토콜 자체의 구성 요소에 대해 논의했으므로 다음으로 넘어가겠습니다.

잠시 시간을 내어보세요.

이것의 뚜껑을 열고 IP 패킷 자체를 살펴보겠습니다.

이는 IP 패킷의 해부학입니다.

시작해 볼까요.

괜찮은.

IP 패킷, IP 패킷 자체의 해부학.

아시다시피, 우리는 이제 좀 더 깊이 파고들어 보겠습니다.

백엔드 엔지니어이자 엔지니어로서 우리는 항상 IP 패킷을 단지 하나의 덩어리로 봅니다.

대상 IP 주소와 소스 IP 주소가 있는 데이터.

나는 적어도 항상 이런 식으로 시각화하지만 모든 부분을 이해하는 것이 아니라 특정 부분을 이해하는 것이 중요합니다.

정말.

내가 믿는 것.

IP 패킷 자체에 대한 몇 가지 중요한 정보가 있으며 이것이 이 강의의 내용입니다.

에 대한.

그렇다면 IP에 대한 IP는 무엇일까요?

여기에는 헤더와 데이터 섹션이 있습니다. 데이터와 헤더라는 두 섹션이 있습니다.

대부분의 경우 우리가 정말로 관심을 갖는 것은 데이터입니다.

우리는 헤더에 대해 실제로 신경 쓰지 않지만 특정 문제를 디버깅하거나 특정 문제를 이해하고 싶다면

이런 상황에서는 이걸 깊이 파고들어야 합니다.

이해해야 할 또 다른 중요한 점은 패킷과 헤더의 크기입니다.

20바이트를 추가하면 그건 IP 헤더이고, 데이터에 20바이트가 더 추가됩니다.

20개의 막대는 실제로는 귀하의 데이터가 아닙니다.

효과적으로 사업을 하는 데 드는 비용이에요.

그리고 무슨 일이 일어났을까요?

특정 옵션이 활성화되어 있으면 최대 60바이트까지 늘어날 수 있습니다.

그래서 저는 그 옵션이 항상 포함되어 있지는 않다고 생각하지만 포함되어 있다면 최대 60바이트까지 올라갈 수 있습니다.

특정 패킷.

따라서 단일 바이트를 보내는 것을 절약하기 위해 이러한 특정 알고리즘이 작동하는 것이 정말 중요합니다.

패킷의 경우, 20개의 헤더가 있고 20바이트 헤더가 있습니다.

시간 낭비일 뿐이고, 단일로 넓게 보내는 것은 자원 낭비일 뿐입니다.

20바이트 헤더를 첨부합니다.

그래서 나이젤이 그들과 지연된 인정을 통해 효과적으로 문제를 해결하려고 노력하는 것과 같습니다.

LS 명령을 단일 패킷으로 보내지 않으려고 노력하세요.

그냥 낭비일 뿐이라는 걸 알지만, 때때로 그게 무섭기도 합니다. 알다시피, 그래서 우리가 그런 걸 가지고 있는 거잖아요.

데이터 섹션은 최대 65,536까지 올라갈 수 있어요. 데이터 자체의 길이가 16이기 때문이죠.

조금.

따라서 65,000에 해당하는 최대 16비트 콘텐츠만 처리할 수 있습니다.

솔직히 말해서 저는 그렇게 큰 IP 패킷을 본 적이 없습니다. 왜냐하면 올바르게 생각해보면,

그리고 우리는 이에 대해 나중 섹션에서 이야기할 것입니다. MTU라고 하는 것이 있습니다.

최대 전송 단위입니다.

따라서 인터넷의 최대 전송량은 1500입니다.

그래서 패킷을 사용하고 모든 단편화 아이디어를 피하려면 1500개 이상의 물을 밀어 넣을 수 없습니다.

IP 패킷에서 조각화 없이.

그래서 클라우드와 Amazon에서 MTU가 있는 맞춤형 하드웨어가 무엇인지 알 수 없지만,

1기가바이트 기가비트를 사용하려면 그것이 가능한지 모르겠지만, 그 수준에는 도달할 겁니다.

하지만 나에게는 단일 IP 패킷에서 그 수준에 도달할 수 없을 것 같아요. 평균은 5500바이트 정도일 거예요.

9000 특정 상황이지만, 그건 대형 프레임에 있고, 그게 전부입니다.

네, 저는 항상 이 IP 패킷을 백엔드 엔지니어에게 추가하고 싶어요.

그것은 다수의 데이터 목적지 IP 주소입니다.

그래서 IP 주소는 제가 가장 오랫동안 IP 패킷을 항상 이렇게 보곤 했습니다. 아시죠, 그리고 효과적으로 말이죠.

이렇게 보면 오른쪽에는 목적지가 있고 왼쪽에는 출발지 IP 주소가 있습니다.

이런 건 아닌 것 같아요.

종이에.

오른쪽.

하지만 저는 개인적으로 이렇게 하는 걸 좋아하는데, 마치 페트루슈카 인형처럼 딱 맞기 때문이죠.

알다시피, 저는 프레임에 따라 패키지를 만듭니다.

세그먼트가 데이터에 적합한지 등등.

오른쪽.

저는 그냥 이런 식이 좋아요.

하지만 실제 IP 패킷은 다음과 같습니다.

무섭죠?

그래서 이것이 실제로 IP 패킷 자체의 모습이며 이것이 참조입니다.

이걸 IP 프로토콜의 RFC, 즉 인터넷 프로토콜에 사용할 수 있어요.

그리고 이건 위키피디아에서 이 모든 것에 대한 요약을 설명한 것입니다.

여기서 우리는 무엇을 보고 있는가?

이것은 수평으로 0에서 31까지 4바이트이므로 8바이트입니다.

비트, 여덟 비트, 여덟 비트 조금.

아시죠, 이렇게 구성되어 있어요.

따라서 첫 번째 행에 4바이트, 두 번째 행에 4바이트를 두어 세 번째 행의 바이트를 다섯 번째 행으로 지정합니다.

마지막 행의 네 번째 바이트입니다.

그러니까 4x5행을 곱하면 앞서 말했던 20바이트가 됩니다.

이것이 선택 사항이며 이는 인터넷 헤드라인에 따라 결정됩니다.

잠깐 이야기해 보겠습니다.

기본적으로 이는 5개이며, 이것이 5바이트, 즉 5개의 행을 설명합니다.

그리고 그 이상이 되면 옵션의 길이가 효과적으로 정의됩니다.

그리고 이건 60까지 올라갑니다.

이제 이 옵션에 뭔가를 추가할 수 있도록 이야기해 보겠습니다.

알다시피, 이건 좋은 일이에요.

IP 프로토콜을 정의하는 사람들은 이를 확장 가능한 방식으로 정의합니다.

불행히도 내가 읽은 내용에 따르면 일부 라우터는 어떤 이유에서인지 옵션을 효과적으로 차단합니다.

알다시피, 위험하거나 그런 거니까요.

그래서 이게 가끔 막히는 경우가 있어요.

아시죠, 인터넷의 슬픈 점은 바로 이거죠.

모든 사람이 규칙을 따르는 것은 아니므로, 결과적으로 예측 가능한 결과를 얻을 수 없습니다.

그렇지 않으면 내가 백업할 때 IP 패킷을 사용하여 데이터를 몰래 넣으려고 했을 것입니다.

패킷 자체에 내 데이터가 들어있습니다.

이것이 얼마나 멋진지 상상해보세요.

알다시피, 우리는 항상 TCP, CDB 2를 기반으로 프로토콜을 구축합니다.

프로토콜 위에 프로토콜을 쌓아 놓고도 그것이 우리에게 어떻게 제공되는지 잊어버립니다.

프로그래머라면 패킷을 작성하고 옵션을 보낼 수 있죠?

안타깝게도, 저희는 이 옵션이 안전하게 도착할 것이라고 보장합니다.

모르겠습니다.

그렇지 않은 것 같습니다.

아시죠, 이런 옵션은 가끔 삭제되기도 하지만, 생각해보면 꽤 멋진 일이죠.

이것이 사용자가 설정한 것인지 아닌지는 모르겠지만, 어쨌든 우리가 이야기한 것은 데이터 부분입니다.

65킬로바이트까지 됩니다. 구체적으로는 64킬로바이트입니다.

이 버전을 살펴보겠습니다.

이건 4개 아니면 6개예요.

우리는 두 가지 IP 프로토콜 버전을 모두 갖고 있지 않죠?

따라서 이것은 특정 비트를 위한 것입니다. 0, 1, 2, 3, 4개의 비트가 있습니다.

저것.

곰곰이 생각해 보면 약간 지나친 조치죠.

4비트.

얼마예요?

숫자가 16개인가요?

오른쪽.

술집으로 가려면.

여덟.

정확히.

15.

오른쪽.

정말 많은 양이죠.

그래서 그들은 IP 프로토콜의 버전 15까지 올라갈 것이라고 상상했지만 안타깝게도 이러한 비트들은

결코 사용되지 않습니다. 알다시피, 우리는 이제 여섯 개에만 사용하므로 다른 부분을 잃어버릴 염려가 없습니다.

그러니 낭비죠.

하지만 오늘날 우리는 그런 것을 가지고 있습니다.

인터넷 헤더 길이.

우리는 이것에 대해 이야기했습니다.

이것은 옵션의 길이를 정의하는 것으로, 기본적으로는 5인 것 같습니다.

오른쪽.

더 추가할 수도 있습니다.

그렇죠.

좋아요.

필요한 것은 20바이트 쓰기 옵션이며 이를 통해 라우터가 읽을 수 있게 됩니다.

옵션이 있든 없든.

이것이 5라면 이 5개의 행을 합치면 1, 2, 3, 4, 5가 됩니다.

길이.

오른쪽.

이는 전체의 길이를 설명합니다.

여기에는 데이터와 헤더가 포함됩니다.

그러니까 이건 앞서 말했듯이 16비트예요. 그러니까 8 더하기 8이에요.

그래서 당신은 힘을 최대 2까지 올릴 수 있습니다

16은 65,000바이트를 제공하며 이는 데이터만을 설명하는 것이 아니라 전체 헤더를 제공합니다.

20이 될 수도 있고, 옵션이 있다면 옵션에 따라 20에서 최대 60까지 계산해 보세요.

거기.

하지만 그렇죠.

분열.

이건 정말 강력한 개념이네요.

안타깝게도 이것을 올바르게 구현하는 것은 매우 어렵고 내가 아는 바에 따르면 대부분의 구현은 실제로

비난을 받는다.

빠른 단편화가 좋은 예입니다.

빠름 모든 패킷이 빠름.

프로토콜은 IP 조각화를 비활성화합니다. 왜냐하면 그것은 온갖 종류의 일을 일으키기 때문입니다.

패킷이 너무 크다면, 우선 조각화가 실제로 무엇인지 이야기해 보겠습니다.

M2에 대해 이야기했었죠?

최대 전송 단위.

이건 실제로 필요하지 않으므로 여기서 이야기해도 됩니다.

그럼 M2에 대해서 이야기하는 건가요?

최대 전송 단위는 프레임 크기입니다.

그리고 우리는 IP 패킷에 대해서 이야기했습니다.

기본적으로 IP 패키지는 단일 프레임에 딱 맞아야 합니다.

그리고 맞지 않는다면 IP 패킷이 어떤 이유로 큰 경우를 의미하는데, 예를 들어 MTU가

1500이고 IP 패킷은 2000입니다.

그러면 여기에는 두 가지 옵션이 있습니다.

IP 패킷이 프레임에 맞지 않습니다.

두 가지 옵션이 있습니다.

이 패킷을 보낸 고객에게 "이봐, 너무 작게 비우라고" 말할 수 있습니다.

당신이 보낸 이 큰 패킷은 rm2에 넣을 수 없습니다.

메시지가 전송됩니다.

어떻게 메시지를 보내나요?

우리는 ICMP 프로토콜, 즉 인터넷 제어 메시지 프로토콜에 대해 이야기했습니다.

메시지는 IP 수단을 통해 추적 경로와 같은 것들을 지불하는 이 프로토콜을 통해 전송됩니다.

우리는 "저는 못해요"라고 말할 겁니다.

이 패킷이 너무 큰가요?

그건 당신이 조각나지 않도록 설정한 경우에만 가능합니다.

하지만 다른 옵션도 있다.

이걸 조각내자.

IP 패킷, 2000.

좋습니다. 1501 프레임을 넣고 500은 다른 프레임에 넣습니다.

즉, 하나의 IP 패킷이 두 개의 프레임으로 분할되었습니다.

따라서 해당 프레임은 두 개의 프레임으로 전송됩니다.

그러니까 패킷 하나가 두 개면 프레임 두 개가 도착하게 되는 거예요.

뭐라고 생각하시나요?

아니요, 반드시 순서대로는 아닙니다.

따라서 호스트는 이 프레임이 조각난 것에 속한다는 것을 이해하고 조립을 시도해야 합니다.

그래서 조립이 필요한 조립이 있습니다.

그 조각은 가장 위험한 것 중 하나죠?

보안 측면에서요.

그리고 사람들이 단편화를 조작할 수 있다는 사실만으로, 저는 이에 대해 자세히 설명하지 않겠지만,

그리고 사이트 전체에 드는 비용도 그거죠.

그러니 원한다면 조각낼 수도 있죠.

오른쪽.

그리고 이렇게 하세요.

우리는 그것에 대해 이야기할 것입니다.

하지만 결과를 이해한다면, 한 프레임은 실패할 수도 있습니다.

다시 보내셔야 해요.

그럼 조각의 일부만 어떻게 보내나요?

매우 복잡하죠?

그렇기 때문이죠.

아시나요?

분열되지 말자.

그러지 말자.

이봐요, 틀에 맞지 않으면 그냥 실패하면 돼요.

따라서 모든 빈 공간에 맞아야 한다는 것을 알고 있는 것을 보내는 것은 클라이언트의 책임입니다.

그 네트워크를 통과할 것입니다.

슬라이드로 돌아가자.

글쎄요, 실제로 이렇게 말할 수도 있겠네요.

그렇죠. 여기에는 아무것도 없으니까요.

그래서.

네, 글쎄요, ID, 이게 조각의 아이디어예요.

그러니까 하나의 패킷이 네 개로 조각난다면,

그러니까 이건 하나, 둘, 셋, 넷이에요.

효과적으로 동아리 깃발의 ID를 적어 보세요. "이봐, 분열해야 할까, 아니면 분열하지 말아야 할까?"

따라서 이것은 문자 그대로 클라이언트에게 외부인지 외부인지를 알려주는 플래그입니다.

빈 봉지가 너무 작으면 이 큰 봉지를 깨야 하나요?

그래서 여기 DF가 있다고 생각합니다. 플래그가 표시되어 알겠습니다. 할 수 있습니다. 할 수 있습니다. 조각화된 조각입니다.

오프셋은 0123이고 이는 조각 자체의 고유 식별자인 ID입니다.

이제 이 모든 것들은 4개의 4개 조각을 사용하여 대형 패킷을 조각냅니다.

실제로 수명이 긴 대용량 IP 패킷이 있는 경우에도 이 문제가 발생할 수 있습니다.

이것에 대해서도 이야기해 보겠습니다.

오른쪽.

모든 IP 패킷에는 실제로 8비트, 즉 카운터를 나타내는 단일 바이트가 있습니다.

이게 매우 흥미로운 점이죠.

수명에 대해 이야기하기 전에, 먼저 문제에 대해 이야기해 보겠습니다. 왜 우리는 이걸 하고 있는 걸까요?

우리는 항상 '왜?'라는 질문을 던지거든요.

무언가가 존재하는 이유는 무엇인가?

너무 큰 것을 왜 조각내야 하나요?

우리에게 살아가는 데 필요한 시간이 왜 있을까?

우리가 잠시 이야기했던 라우팅이라는 아이디어 때문입니다.

패킷은 여러 경로로 이동할 수 있나요?

결국 무한 루프에 빠지는 상황에 빠질 수도 있습니다.

우리는 이 길, 이 길로 갈 것입니다. 그리고 이론은 거기에 있고 이 길로 돌아갈 것입니다.

동일한 라우터와 패킷은 무한히 이동할 수 있으며 라우터 때문에 이것을 방문했는지 알 수 없습니다.

상태가 저장되지 않습니다. 상태를 저장하지 않습니다.

IP 프로토콜은 상태 비저장입니다.

아시다시피 그들은 해당 프로토콜의 상태를 저장하지 않습니다.

예를 들어, 이 패키지는 이전에 방문한 적이 있는데, 우리가 상태를 가지고 있는 레이어 레이어와는 달리,

세션에는 필요한 모든 것이 있습니다.

IP는 상태가 없으며 IP 패킷이 그냥 통과하지 않습니다.

그래서 국가는 존재하지 않습니다.

그러면 패킷이 영원히 인터넷에서 돌아다니는 것을 어떻게 막을 수 있을까?

살아갈 시간을 만나다.

패킷을 보낼 때, "알았어요"라고 말하라고 하죠.

이 패킷은 100개 경로 동안 유지될 것으로 추정하나요?

그러니까 여기에 100을 넣습니다.

나는 가라고 말한다.

이 패킷은 u L에서 시작하여 호스트에 도달합니다.

당신은 관문을 알고 있죠.

물론.

인터넷으로 보내는 경우 게이트웨이, 즉 라우터로 전송됩니다.

라우터는 패킷에 -1을 적용합니다.

그래서.

IP 패킷이 물리 계층에 도착하면 데이터 링크로 변환됩니다.

프레임을 프레임으로 변환했습니다.

오른쪽.

IP 패킷으로 변환됩니다.

아시죠, 한 프레임을 단순하다고 가정해 봅시다.

하나의 프레임이 단일 IP 패킷으로 들어갑니다.

그게 가장 좋은 시나리오예요.

우리는 IP 패킷을 가지고 있으며 라우터는 해당 IP 패킷을 가져와서 수명을 1만큼 감소시킵니다.

다시 보내주세요.

그래서 동일한 모델로 돌아가서 인터넷과 모든 라우터 및 호스트로 이동합니다.

이 패킷을 보면 감소합니다.

그게 책임이며 계약이에요.

이런 식으로 우리는 패킷에 바로 상태를 추가할 수 있습니다.

당신은 무상태 대 상태 개념을 알기 전에 프로그램을 알고 있습니까? 무상태에 대해 상태와 무상태에 대해 개념을 알고 있습니까?

요청과 함께 바로 정보를 보내주세요.

물론 이 경우에는 IP 패킷입니다.

오른쪽.

그것도 함께 보내세요.

따라서 이제 상태는 호스트에 데이터를 저장하는 대신 항상 데이터 자체를 따릅니다.

오른쪽.

그러니 이제 이 시간을 부자로 사는 걸로 바꿔 말하면, 그것을 0으로 줄이는 사람은 멈춰야 한다는 걸 알죠.

패킷을 삭제하고 ICMP 메시지를 다시 보내야 합니다.

ICMP가 다시 표시됩니다.

그래서 제가 설명한 거예요.

매우 비판적이에요.

ICMP 프로토콜이 다시 나타나고, 패킷 시간이 초과되었다고 표시됩니다.

아니요, 저는 그 정확한 메시지를 기억하지 못하며 그 메시지를 출처로 다시 보내겠다고 말씀드리겠습니다.

IP 주소.

이것이 바로 Traceroute가 작동하는 방식입니다.

Traceroute나 라우터 경로도 똑같습니다.

추적자를 추적하거나 경로를 추적합니다.

영국에서는 라우터라고 부르는 것 같아요.

응.

그러니까 라우터, 라우터를 아시죠.

오른쪽.

0에 도달할 때까지 감소시킨 다음 소스에 메시지를 보내서 '이봐, 이거지'라고 말합니다.

완료.

그래서 추적 경로는 실제로 이런 식으로 진행됩니다.

이는 매우 짧은 수명을 설정하고 이를 증가시킵니다.

그리고 우리가 한 홉을 지날 때마다, 우리는 다음 홉에 도달하게 됩니다.

해당 라우터는 우리에게 소스 IP 주소를 알려줄 것입니다.

그래서 우리는 전체 경로를 효과적으로 추적할 수 있습니다.

분명히 일부 라우터는 ICMP를 완전히 비활성화하고 일부 방화벽은 ICMP를 비활성화합니다.

여기서 점, 점, 점, 점, 추적 경로가 나옵니다.

그 특정한 사례에서는 기본적으로 추적이 불가능합니다.

그럼 이제 매우, 매우 중요한 개념을 설명할 차례입니다.

이 패킷은 몇 개의 홉을 견뎌낼 수 있습니까? 그리고 이것은 일반적으로 128 숫자이거나 당신이 말한 대로 큰 숫자입니다.

숫자가 너무 크지 않도록 하세요. 패킷은 결국 오랫동안 살아있게 될 테니까요.

아시다시피, 기본 숫자가 충분하더라도 패킷이 더 많이 소요되는 경우를 보면,

아마도 경로가 더 길어지고 죽어가고 있을 것이고 아마도 클라이언트가 그 수의 프로토콜을 늘릴 것입니다.

말하다.

IP 주소를 통해 우리가 알고 있는 바를 말하고 있는 거예요.

아니요. 이것은 이 데이터 내부에 들어있는 콘텐츠에 대한 프로토콜입니다.

아니요, 저는 이걸 처음 봤을 때 항상 이게 왜 논쟁의 여지가 없는지 생각했습니다.

저는 프로토콜을 정의해야 하고, 당신은 제 프로토콜에 대해 알아야 합니다.

이것을 무작위 데이터로 전송하고 싶습니다.

반드시 프로토콜일 필요는 없습니다.

나는 나만의 프로토콜을 만들고 싶다.

그럼 나를 차단할 건가요?

저는 이런 생각을 했었죠?

예를 들어, 데이터를 읽고 프로토콜을 파악하는 거죠.

그래서 제 마음에 가장 먼저 떠오른 생각이 그거였어요.

왜 8비트의 낭비가 더 필요한가요?

그러자 저는 생각해 보았습니다.

아시나요?

사실 좋은 아이디어가 있어요.

이렇게 하면 라우터가 전체 데이터를 전달할 필요가 없습니다.

그들은 20바이트 헤더를 읽고 그 안에 무엇이 있는지, 그리고 그것이 무엇인지 즉시 알아낼 수 있습니다.

데이터를 가져와야 할지 말지.

아시죠, 정말 독창적이에요.

실제로 우리는 항상 이렇게 합니다.

아시다시피, 이건 성능을 저장하기 위한 메타데이터입니다.

그리고 당연히 차단하기로 결정했거나 다른 일을 하려고 할 겁니다.

이 프로토콜을 읽으면 됩니다.

따라서 우리의 프로토콜은 ICMP가 TCP인지, UDP인지, 어떤 내용인지에 관계없이 포함될 수 있습니다.

IP, IP 데이터 자체가 여기의 프로토콜입니다.

위키피디아에 목록이 있는데, 내가 공유해서 모든 프로토콜을 보여드릴 수 있다면 좋겠어요.

그 프로토콜 서버와 지정해 놓으면 그냥 잡다한 것 같은 것 같은데요.

여기에 모든 것을 넣을 수 있어요.

분명히 베이 8비트가 있죠.

그럼 몇 명이나 있나요?

최대 255개의 프로토콜을 가질 수 있지만 그게 전부입니다.

출발지 및 목적지 IP.

여기서 가장 중요한 메타데이터는 헤더, 어디로 가는지, 어디에 있는지입니다.

에서 유래.

매우 중요한 정보입니다.

누구나 소스 IP 주소를 위조할 수 있습니다.

알다시피, 시도해 볼 수는 있어요.

그러니까, 내 IP 주소가 모두 위조되었다는 거죠.

아시다시피, 여기 많은 사람들은 "이건 이게 아니야"라고 말합니다.

우리 포럼에서 귀하의 IP 주소를 확인했습니다.

아니, 그건 내가 아니었어요.

내 IP 주소가 위조되었습니다.

내 생각은 이렇습니다. 스푸핑은 쉬운 일이잖아요, 그렇죠?

스푸핑은 출처를 바꾸는 아이디어입니다.

귀하의 머신에서 직접 보내는 모든 패킷은 효과적으로 소스 IP 주소를 변경합니다.

뭔가 다른 것이 되세요.

그럴 수 있지?

하지만 무슨 일이 일어났을까요?

귀하의 ISP, 패킷, IP는 라우터를 거쳐 첫 번째 라우터로 전달됩니다.

주요 라우터에 영향을 줍니다.

첫 번째 주요 라우터는 무엇입니까?

그것은 인터넷에 대한 링크이기 때문에 ISP이고, 예를 들어 내 소스 IP 주소라고 말할 것입니다.

사실 그 사람이 뭐든 상관없어요. 원하는 숫자를 입력할 수 있고 간단하게 쓸 수도 있어요.

그런 일을 하는 코드는 모든 IP 패킷을 다시 작성합니까?

오른쪽.

소스 IP가 다른 것일 수도 있지만, ISP가 이를 알려줄 것입니다.

잠깐만요. 그건 당신의 IP 주소 출처가 아닙니다.

귀하의 IP 주소를 알고 있습니다.

내가 당신에게 할당한 것은 당신이 항상 실제로 블록을 가지고 있을 것이라는 것이었습니다. 아니, 당신은 그것을 제대로 할 수 없습니다.

하지 않는 한.

네, 모든 인터넷 제공업체가 이런 차단 기능을 갖고 있을 거예요.

더 이상 속일 수 없습니다.

아시다시피, IP 주소를 스푸핑하는 것은 쉽지 않습니다. 자체 ISP를 구축하지 않는 한 말입니다.

저는 불가능하다고 생각하지 않아요.

그렇게 한 다음 자신의 ISP를 운영하고, 인터넷에 연결하려면 비용을 지불하면 됩니다.

네, 그럼 원하는 만큼 스푸핑을 할 수 있지만, 스푸핑을 하더라도 어떻게 응답을 받을 수 있겠어요?

뒤쪽에?

그게 반응을 얻는 데 쓰이거든요.

그렇죠. 목적지 IP는 어디로 가는지이고, 출발지 IP는 어디에서 오는지입니다.

매우 비판적이에요.

그리고 이것들은 우리가 바이트에 대해 이야기했듯이 이것이 IPV 4가 명시적으로 쓰기 가능한 것입니다.

혼잡 알림.

이에 대해서는 TCP 섹션에서 더 자세히 설명하겠습니다.

하지만 이 부분은 실질적으로 하위 계층에서 나온 것, 또는 상위 계층에서 상위 계층으로 나온 것입니다.

이 비트는 라우터에 의해 설정됩니다.

혼잡 알림에 대해 이야기하기 전에 명시적인 혼잡 알림이 의미하는 바가 무엇인지 알려드리겠습니다.

그리고 또, 이에 대해서는 나중에 자세히 이야기하겠지만, 이야기해도 손해는 없을 것 같습니다.

지금.

혼잡은 패킷이 손실되기 시작하는 시점입니다.

IP 패킷은 홍수처럼 라우터에 도착합니다.

아시다시피, 모두가 데이터를 보내고 있죠.

내가 말하는 순간, 나는 모든 사람에게 데이터를 보내고 있습니다.

생명에 위협이 되는 일은 아니지만, 요점은 알겠죠.

이걸 플레이하고 있다면 패킷이 라우터를 통해 들어오고 있다는 뜻이에요.

아시다시피, 결국 라우터는 이 패킷을 처리하기 위해 일정량의 메모리가 필요합니다.

패킷을 넣기 위해 버퍼를 호출합니다.

이 기억이 채워진다.

패킷이 너무 많거나 라우터가 느리면 많은 작업을 수행하는 것과 같이 가득 찰 경우

통과하다.

일이 많아질수록 시간도 많아진다.

시간이 길어질수록 대기열이 길어지고 버퍼가 실패합니다.

버퍼에 장애가 발생하면 더 이상 패킷을 수신할 수 없습니다.

즉, 들어오는 패킷을 삭제해야 한다는 뜻입니다.

라우터 컨트롤러에 도착하는 모든 패키지는 패킷을 삭제하고 해당 패킷이 삭제되면

혼잡이라는 현상을 나타냅니다.

즉, 네트워크가 혼잡하거나 라우터가 처리에 어려움을 겪고 있다는 의미입니다.

패킷이 멈춥니다.

따라서 혼잡 제어, 인터넷 트래픽 제어에 대한 전체적인 솔루션이 있습니다.

가장 오랫동안 혼잡 통제라고 불렸습니다.

라우터는 항상 패킷을 삭제합니다.

야, 패킷 내려놓아.

그게 아무런 메시지를 보내지 않는다거나 그런 건 상관없어요.

그냥 내려놓고 그대로 두세요.

아시다시피 ICMP 메시지도 보내지 않아요.

저는 그렇게 생각하지 않아요.

클라이언트는 내 패킷이 시간 초과된 것으로 추측해야 합니다.

확인 메시지가 보이지 않습니다.

사라졌고, 떨어졌고, 혼잡했을 것이라고 가정하겠습니다.

그런 일이 일어납니다.

시간 초과가 너무 길어서 낭비이고 기다려야 합니다.

더 나은 의사소통이 필요합니다.

라우터에서 명시적인 혼잡 알림을 충족합니다.

IP 패킷이기 때문에 버퍼가 가득 차면 3계층 패킷만 처리합니다.

그들은 이 패킷을 받아서 이렇게 말할 것이다.

이걸 제 양동이에 떨어뜨릴 참이에요.

정말 아름다워요.

하지만 잠깐만요.

저는 실제로 그것을 떨어뜨리지 않을 겁니다.

버퍼가 고장나려고 합니다.

쉽게 느껴질 거 알아요.

N이 한 사람에게 그렇게 말했지?

무엇이든.

붐 알림을 실제로 설정하세요.

이제 곧 채워질 예정이고 그러면 실제로 처리될 겁니다.

그러면 수신자는 그 비트를 볼 수 있게 됩니다.

오오.

실제로 일부 라우터는 혼잡을 경험합니다.

수신자에게 전하는 게 낫겠어요.

따라서 TCP 계층 텍스트 제어는 혼잡을 경험하는 곳이며 클라이언트가 시작됩니다.

더 높은 수준에서 소통합니다.

TCP 전송 계층은 괜찮고 혼잡이 발생합니다.

따라서 여기서의 장점은 이 작은 변경으로 클라이언트와 서버 모두에게 알림을 보낼 수 있다는 것입니다.

오른쪽?

서버는 동일한 비트로 클라이언트에게 응답하므로 결국 모든 사람이 알게 될 것입니다.

그들은 패킷이 삭제되지 않고도 혼잡이 있다는 것을 알 수 있습니다.

디자인이 아름답네요.

저는 이렇게 작은 조각으로 얼마나 우아한 작품을 만들 수 있는지 정말 좋아합니다.

솔직히 말해서, 모르겠어요.

왜 더 자세히 설명해야 할까요? 하지만 요점은 이렇습니다.

아름다운.

저는 이걸 정말 좋아해요.

아시다시피, 우리는 이러한 우아한 디자인에서 백엔드 엔지니어로서 많은 것을 배울 수 있습니다.

우리는 애플리케이션을 빌드할 때 많은 것을 낭비합니다. 우리는 모든 종류의 것을 빌드하고, 알다시피, 우리는 배열을 할당합니다.

제이슨 블로티드 제이슨이 수천, 수천 개나 만들었죠.

우리는 열쇠를 곳곳에 복사해 둡니다.

우리는 데이터베이스에서 중복된 응답을 받았습니다.

우리는 그것을 어디에나 두었습니다.

우리는 필요 없는 정보를 보냅니다.

그래서 제가 방금 백업한 API로부터 응답을 볼 때마다 이 모든 것이 정말 속상합니다.

아시다시피, 우리는 같은 값을 계속해서 보냅니다.

이런 종류의 일들은 옛날에는 그들이 일할 수 있는 한계가 있었고 그들이 감사했다는 것을 깨닫게 합니다.

이 한계.

오늘.

엔지니어 우리에게는 한계가 없습니다.

램, 램이 뭐예요?

나는 상관하지 않아.

저는 700기가바이트 램을 가지고 있어요.

나는 상관하지 않아.

내가 원하는 모든 것을 살펴보겠습니다.

그리고 불행히도 우리는 그 희소성의 근원을 잃었습니다.

이건 그냥 제 불평일 뿐이고, 이게 제가 설명하고 싶은 가장 중요한 내용이에요.

헤더에 관해서 말하자면, 헤더의 IP입니다.

좋습니다. 저는 항상 이 IP 패킷을 요약했습니다.

IP 패킷은 가장 우아한 해부학 중 하나입니다.

패킷에는 헤더가 있는데, 20바이트이고 옵션이 있고 활성화되어 있으면 최대 60바이트까지 늘어날 수 있습니다.

데이터 섹션은 65,000바이트까지 들어갈 수 있습니다.

그렇게 큰 IP 패킷을 본 적이 없습니다. 맞는 MTU가 없거든요.

우선, 16비트가 실제로 너무하다고 주장할 수도 있지만, 무슨 일이 일어날지 알 수 없습니다.

아마도 Amazon Cloud Cloud, Amazon Cloud 또는 Microsoft Azure 또는 Google에서 자체 네트워크를 구축할 것입니다.

실제로 65,000에 달할 수 있는 대용량 MTU와 인터페이스합니다.

누가 알겠나?

그들은 이 정보를 우리와 공유하지 않습니다.

따라서 그렇게 큰 프레임이 있다면 하나의 IP, 큰 IP 패킷을 보낸 다음 단일 프레임에 맞출 수 있습니다.

액자.

저는 그것의 한계를 모르고, 그렇게 하면 무슨 문제가 생길 수 있는지도 모르겠습니다.

아마 사람들이 시도해 볼 수도 있겠지만, 확실히 지연 시간은 줄어들 것입니다, 맞나요?

모든 장치가 긴밀하게 고대역폭 네트워크를 갖고 있는 자체 네트워크가 있는 경우, 나는 그렇지 않습니다.

인터넷에 접속합니다.

그건 나만 아는 사실이에요.

이건 내 책임이야.

데이터베이스를 종료하고 백엔드 애플리케이션에 연결하면 모든 것이 100개입니다.

기가비트 이더넷과 MTU 65K MTU를 사용하는데, 그걸 사용하려고 합니다.

물론, 인터넷에 접속하지는 않을 겁니다.

그러니까 이건 긴밀한 로컬 에어리어 네트워크예요. 그러니까 모든 걸 최적화하는 거예요.

그래서 언젠가 이걸 보고 싶어요.

그래서 만약 누군가가, 내가 읽고 싶은 기사나 무언가가 있다면, 누군가가 실제로 이점을 활용하는 것을 보고 싶습니다.

또는 그에게 어떤 제한이 있는 경우, 우리가 이야기한 패킷의 크기는 조각화되어야 합니다.

프레임에 맞지 않으면 내 깃발을 조각내지 마세요라는 베팅을 설정하지 않는 한

우리는 "조각나지 말자"는 것에 대해 이야기했습니다.

그리고 당신이 조각화하지 않으면, 그 패킷이 당신에게 너무 크다면, 우리는 실패하고 그것을 삭제합니다.

패킷을 보내고 우리는 클라이언트에게 "안녕하세요, 당신이 우리에게 그렇게 하지 말라고 했기 때문에 우리는 당신의 자료를 조각낼 수 없습니다"라고 말합니다.

파편.

오른쪽.

ICMP가 등장하는 부분입니다.

어, 사실 블랙홀 연결이 일어날 수 있는 곳이 여기예요.

이에 대해서도 앞으로 이야기해 보겠습니다.

블랙홀 TCP 연결.

구글로 검색해 보세요.

괜찮은.

그것은 IP 패킷이었습니다.

어떻게?

다음 강의로 넘어가겠습니다.

좋아요, 여러분.

ICMP는 3계층에 있는 가장 중요한 프로토콜 중 하나이며, 우리는 이에 대해 많이 논의했습니다.

하지만 실제로 설명해야 할 부분은 바로 여기입니다.

Ping을 사용한 적이 있다면 그것은 ICMP입니다.

만약 당신이 traceroute를 사용한다면 그것은 ICMP입니다.

우리는 이 프로토콜을 이해하기 쉽게 설명하고 이것이 얼마나 중요한지 이야기하겠습니다.

우리 함께 뛰어들어 볼까요?

ICMP는 인터넷 제어 메시지 프로토콜을 의미하며 3계층에 있습니다.

그게 무슨 뜻이에요?

즉, 목적지와 출처 IPA만 있다는 뜻입니다.

해당 계층에는 포트라는 개념이 없습니다.

항구가 없습니다.

아시다시피 항구가 없습니다.

그러니 이건 단지 정보 제공일 뿐이에요.

호스트 간의 메시지.

아름다운.

아니, 매우 비판적일 뿐이에요.

그래서 우리가 같은 언어를 사용하고, 같은 언어로 말하는 거예요.

3계층이라고 하면 무슨 뜻인지 알겠죠. 4계층이라고 하면 바로 포트가 열리죠.

항구를 생각해 보세요.

TCP에 대해 생각해 보세요.

교통 혼잡 통제에 대해 생각해 보세요.

그런 것들을 생각해보세요.

수업이 진행됨에 따라 점점 더 명확해질 겁니다.

정보 메시지를 호스팅하도록 설계되어 있어 도달할 수 없습니다.

존재하지 않는 호스트에게 메시지를 보냈네요.

ICMP 포트에 접근할 수 없습니다.

포트는 4계층 개념이지만 ICMP는 포트에서 다시 전송되는 3계층 개념입니다.

섬기는 사람.

따라서 존재하지 않는 서버의 포트에 도달하려고 하면 해당 포트가 ICMP 메시지를 다시 보냅니다.

활성화하면, "Hey port unreachable"이라고 나옵니다.

호스트에 도달할 수 없는 조각화가 필요합니다.

우리는 그 분열에 관해 5분 동안 이야기했습니다.

안녕하세요, 패킷이 너무 커서 분할해야 합니다.

패킷 만료 무한 루프 및 라우터는 "이제 살 때가 됐어"라고 말하며 우리가 이야기했던 것들을 살립니다.

오른쪽?

우리가 감소를 유지하고 그들이 감소시킬 때까지는 히트에 도달할 때까지 그리고 패킷이 될 때까지

만료됨, 0, 죽음.

ICMP 메시지를 보내면 항상 IP를 직접 사용하고, ping과 TRACEROUTE는 이를 사용합니다.

리스너나 포트를 열 필요가 없다는 것에 대해서도 이야기했죠.

저는 이런 종류의 컨셉을 추가하는 것을 좋아합니다.

다른 것은 절대 찾을 수 없을 거예요.

많은 사람들이 이를 당연하게 여기기 때문입니다.

하지만 저는 이 점을 강조하고 싶습니다.

ICMP 메시지를 수신할 포트가 없습니다.

ICMP 메시지는 언제든지 보낼 수 있죠.

호스트 자체가 ICMP를 활성화하는 한, 즉 프로토콜을 사용하여 IP 패킷을 IP 패킷과 함께 전송하는 것을 의미합니다.

ICMP로 설정하고 포트도 없고 그런 건 아무것도 없습니다.

이러한 에코 메시지를 원하는 대로 보낼 수 있습니다.

ICMP 헤더는 이렇게 생겼어요.

이건 기본적으로 RFC 792에서 따온 겁니다.

ICMP 메시지를 볼 수 있습니다.

매우 간단하죠.

아시다시피, 그들이 말했듯이 4바이트, 4옥텟이에요.

맞죠?

가난한 사람은 한 명씩, 두 명씩, 세 명씩.

그러니까 코드에는 흰색이 있는 거예요.

당연히 최대 255개의 코드를 사용할 수 있고, 메시지 유형을 작성할 수 있습니다.

그러니까 이게 유형이고, 이게 하위 유형인 거죠.

여기에는 모든 것의 목록과 같은 것이 있으며 모든 목록은 여기에 효과적으로 체크섬이 있습니다.

이 메시지가 손상되었는지 아닌지, 나머지 헤더는 알다시피, 일부 방화벽은 ICMP를 차단합니다.

보안상의 이유도 있겠지만, 여러분도 알다시피 인터넷의 슬픈 점은 바로 이겁니다.

아시죠, 뭔가 멋진 걸 만들죠.

인터넷에서는 좋은 것이 존재할 수 없습니다.

사람들이 좋은 것을 만들었는데 공격자는 ICMP를 악용해 나쁜 짓을 하는 방법을 찾아냈습니다.

아시다시피, 어떤 사람들은 그것을 이용해 플러딩 공격을 감행하고 ICMP 메시지를 특정 서버로 플러딩합니다.

어떤 사람들은 그것을 사용하고, 어떤 사람들은 그것을 백채널 공격에 사용합니다.

서버를 조사하려면 활성화된 특정 포트를 찾아야 합니다. 예를 들어 일부 방화벽이 그렇습니다.

실제로 ICMP를 차단하거나 일부 방화벽은 ICMP 메시지를 시간 초과합니다.

지금 ICMP 요청이 너무 많아서 잠깐 시간을 초과하겠습니다.

예를 들어, 이 경우에는 핑크가 효과적이지 않을 수 있습니다.

따라서 당신이 확실히 살아 있다는 것을 알고 있는 기계에 핑을 보내고 있다는 사실에 대해 궁금해 하십니까? 그러나 당신의 고통은 다음과 같습니다.

진행되지 않나요?

호스트를 사용할 수 없기 때문에 전송이 실패할 수도 있습니다.

하지만 대부분의 경우 패킷 중 하나만 생각하잖아요, 맞죠?

당신이 ping을 보내고 있는 라우터는 IP 패킷을 통과하고 있습니다. 왜냐하면 그것은 단지

ICMP가 있는 IP 패킷.

정말 아무것도 아니고, 특별한 것도 없습니다.

그리고 그것이 하는 일은 ICMP 때문에 IP 패킷이 삭제된다는 것입니다.

차단되었습니다.

따라서 ICMP를 비활성화하면 연결 설정에 실제적인 손상이 발생할 수도 있습니다.

이를 효과적으로 TCP 블랙홀이라고 합니다.

그러면 연결을 설정해야겠죠?

하지만 그 후에 시작하세요.

TCP 3방향 핸드셰이크에 대해 이야기해 보겠지만, 그것은 아주 작습니다.

아시다시피, 당신이 보내는 데이터는 보내고 다시 보내고 하는 거죠.

오른쪽.

하지만 IP 패킷이 너무 작아서 그런 것도 통과되지는 않습니다.

하지만 실제 데이터를 전송하기 시작하는 순간.

오른쪽.

오른쪽.

그리고 당신은 말합니다. 분열하지 마세요.

그리고 MTA 중 하나가 들어왔습니다.

장치가 너무 작아서 라우터를 조각내야 메시지를 보내려고 합니다.

ICMP 메시지에서 "안녕하세요, IP 패킷이 MM2에 비해 너무 큽니다. 더 작게 만들어 주세요."라고 나옵니다.

하지만 무슨 일이 일어났을까요?

ICMP가 차단되어 있죠?

차단되면 절대로 ICMP 메시지를 받을 수 없고, 절대로 접속할 수 없습니다.

갑자기 TCP 연결이 열려 있는 것을 보았지만 데이터가 어디로도 전송되지 않습니다.

무슨 일이 일어나고 있나요?

마치 블랙홀을 여는 것과 같습니다.

문자 그대로 TCP IP 블랙홀이라고 불리는 것입니다.

구글로 검색해 보세요. 잠시 후에 잠깐 패닉 데모를 해 볼게요.

여기에 뭔가를 핑해보겠습니다.

핑을 보내겠습니다.

Ping은 말 그대로 모든 운영체제에서 사용할 수 있습니다.

그럼 ping 192168.254.2 54를 선택해 보죠.

이게 사실 제 라우터예요.

따라서 이 ping을 발견하면 ICMP 시퀀스 메시지를 보내는데, 여기에는 제목이 지정됩니다.

아, 이제 우리는 그걸 알았지?

TTL 수명 64.

제목: Time to Live 반복 및 오름차순 64바이트.

오른쪽.

그리고 이것은 ICMP가 이 라우터에 도달하는 데 걸리는 시간과 라우터에서 나에게 돌아오는 데 걸리는 시간입니다.

6밀리초예요.

이것에 대해 조금 천천히 생각해 보세요.

제 딸이 바로 저기 있어요.

왜 와이파이를 통해서만 걸리는 걸까요?

왜냐하면 제가 와이파이에 접속했기 때문이죠.

하지만 이걸 보세요.

때로는 11밀리초, 때로는 12밀리초.

그거 정말 미친 짓이야, 알겠지?

하지만 이건 ICMP 시퀀스예요.

이런 걸 이해하는 건 참 멋진 일이죠.

오른쪽?

그럼, 시작해볼까요.

Google.com을 가져와 봅시다.

핑.

Google.com.

ping의 기능은 다음과 같습니다. 우선 ping은 IP 주소에서만 작동합니다.

Google.com은 IP 주소가 아닙니다.

그래서 DNS는 IP 주소를 찾습니다.

오른쪽.

그러니 Bing이 여기서 더 많은 일을 합니다.

IP 주소를 알려주세요. 그러면 ping을 보내서 더 큰 거래를 하기로 결정했다는 것을 알 수 있을 겁니다.

이제, 구글이 더 멀리 있기 때문에 추정할 것입니다.

좀 더 큰 제목을 붙이자면, 이거 보세요.

구글은 라우터와 거의 비슷해요.

1,200만 9밀리초인데, 제 라우터는 6밀리초예요.

라우터가 왜 이렇게 느린지 확인하고 지금 당장 라우터를 업그레이드해야 할지 고민입니다.

하지만 이건 정말 흥미로운 내용이네요.

슬라이드로 돌아가자.

알았어, 핑.

ping은 이렇게 작동하며 대상 서버는 다음과 같습니다.

괜찮은.

내가 그리기 위해 많은 시간을 들인 아름다운 다이어그램이 무엇인지 설명하겠습니다.

매우 훌륭한 애니메이터예요.

오른쪽.

아마 이미 알고 계실 겁니다.

따라서 19216 100은 첫 번째 라우터이고 3800은 두 번째 라우터입니다.

그러니까 이것은 네트워크예요.

이것은 네트워크입니다.

그리고 이것이 그 네트워크를 위한 강아지 장치입니다.

1.2.68 5800.

이것이 네트워크이고 이것이 장치입니다, 10.100.

이것은 또 다른 네트워크입니다.

그래서 우리는 연결되어 있죠.

우리는 많은 네트워크를 서로 연결하고 있습니다.

그러니까 앞서 말했듯이, 이 라우터는 두 개의 네트워크에 속하죠?

이 녀석과 이 녀석, 이 라우터는 두 네트워크에 속해 있어요.

네트워크를 구축할 또 다른 블록이 있습니다.

이 라우터 두 개는 하나의 네트워크에 속합니다.

오른쪽.

그리고 이것은 단지 여러 장치 중 하나일 뿐입니다.

그럼 제가 패킷을 보내면, 200 ICMP 에코 요청을 보내게 됩니다.

그게 그 뜻이 맞죠?

안녕하세요, 192168이나 10.3으로 가고 싶습니다.

그래서 이 사람.

192.168.123.

우리는 우리가 이야기했던 모든 일을 다 합니다.

알겠어요. 서브넷 마스크를 쓰거나 당신과 내 서브넷을 쓰세요.

아니, 그렇지 않아요.

제가 바로 보내드리겠습니다.

그리고 메시지를 통해 패킷이 해당 위치에 도달하면 모든 TLS를 감소시킬 것입니다.

오른쪽.

따라서 100에서 96에 도달합니다.

그러니까 하나, 둘, 셋, 넷.

오른쪽.

그렇군요.

오른쪽.

그리고 호스트가 실제로 그것을 감소시키는지 확실하지 않습니다.

우리는 그것을 연구해서 ALK가 95나 96인지 확인할 수 있어요.

정말 모르겠어요.

하지만 라우터가 감소한다는 걸 알아요.그래서 우리는 거기에 도달했어요.

그러니까 ping이 작동하는 방식은 서버를 울리는 것이었습니다.

ICMP를 지원하는 경우 ICMP 에코 응답으로 다시 응답하고 소스 제목을 재설정합니다.

목적지는 1921682123이고 소스는 10 대 3이며 모든 서브넷 마스크 셰뱅을 수행한 다음

붐, 보내주시면 우리가 처리해 드리겠습니다.

ping은 이렇게 작동합니다.

갑시다.

도달할 수 없는 ping입니다.

저는 192168 혹은 1023으로 보내고 있는데, 바로 저기에 있고 161 1.123입니다.

오른쪽.

하지만 제목을 보세요.

여기서는 테스트 목적으로 시간을 측정하기 위해 특별히 3으로 설정했습니다.

여기까지 도달했습니다.

두 개가 되고, 패킷이 여기에 도달하면 라우터는 그것이 하나가 되고, 바로 여기에 도달한다고 판단합니다.

다른 하나는 그것이 0이 되도록 결정합니다.

잠깐만요, 연결할 수 없습니다.

떨어뜨리기 전에 라우터를 먼저 떨어뜨려야 해요.

이를 삭제한 다음 ICMP 대상을 전송합니다.

IP 패킷만 있기 때문에 ICMP 메시지에 도달할 수 없습니다.

그것은 단지 IP 패킷일 뿐입니다.

참 아름답네요.

모든 것은 여기 3계층 라우터에 대한 IP 패킷일 뿐이며, 우리는 이 모든 아름다운 것들을 보내고 있습니다.

남자 1921688.

하나 둘 셋.

Target은 제가 당신이 그것을 다시 돌려보내길 원하는 곳입니다.

네, 이걸 보세요.

전송 중입니다.

우리는 출처가 누구인지 알려주겠습니다.

하지만 여기서 출처는 누구인가?

이제 소스는 이 라우터 $160이 되었습니다.

500.

이제 이걸 보세요.

그래서 이제 우리는 기계를 가지고 또 다른 패킷을 받았는데, 그 패킷은 누가 보냈는지 알고 있습니다.

이것은 traceroute의 전체 구현입니다. 왜냐하면 tail이 바로 여기에서 죽기 때문입니다.

라우터가 ICMP 대상에 도달할 수 없음 등의 메시지를 다시 보냅니다.

여기서 일어나는 일은 사실상 우리가 이걸 보낸 사람이 누구인지 안다는 거죠?

우리는 패킷이 어디에서 죽는지 알고 있는데, 그것이 아름답습니다.

추적 경로 또는 경로를 추적합니다.

IP 패킷의 전체 경로를 식별할 수 있나요?

이것은 질문의 올바른 대답 수준을 추적하는 것입니다.

오른쪽.

그리고 이제 아마 천천히 점진적으로 설명하면 라우터 IP 주소를 얻을 수 있을 것입니다.

각 홉마다.

그러니까 당장 얻을 수 있는 것부터 시작하는 게 맞지요?

이는 감소하여 0에 도달하고 즉시 ICMP 메시지로 응답합니다.

오른쪽.

경로가 바뀌면 항상 작동하지는 않습니다.

오른쪽.

ICMP가 차단되었을 수도 있습니다.

오른쪽.

여기서 문제는 ICMP가 차단되면 아무것도 할 수 없다는 것입니다.

다만 아무것도 할 수 없습니다.

또 다른 점은 귀하의 패킷이 한 경로를 취할 수 있지만 귀하가 보내는 두 번째 제목은 걸릴 수 있다는 것입니다.

다른 경로를 선택하면 잘못된 결과가 나올 수 있습니다.

따라서 traceroute는 사실 100% 정확하지 않습니다.

이건 제가 traceroute에 대해 만든 애니메이션이에요.

그러면 TTL을 보내는 게 어떨까요?

이 애니메이션을 보셨죠.

여러분께서 제 아름다운 애니메이션을 감상해 주셨으면 해서 다시 한 번 만들어보려고 합니다.

이 TTL을 보세요.

우리는 그것에 하나의 에코를 보내고 그것을 그 목적지로 보낸 다음 즉시 누구로부터 응답을 받습니다.

1800은 목적지에 도달할 수 없다고 말합니다.

왜?

우리는 그것을 즉시 문서화하고 완료하도록 설정했기 때문입니다.

이제 우리는 내 패킷이 이 사람을 통과했다는 것을 알게 됐습니다.

좋습니다. 지금부터 말씀드리겠습니다.

첫 번째 라우터에서 1을 뺀 값이 유지됩니다.

2번째는 살아남지 못해요. 왜냐하면 -1을 보내고 나서 -1을 보내면 0이 되거든요.

그리고 바로 여기서 죽습니다.

이제 두 번째 라우터를 갖게 됐습니다.

그래서 첫 번째가 있습니다.

Traceroute의 작동 방식은 다음과 같습니다.

우리는 첫 번째 홉을 알고 있습니다.

이게 두 번째 홉인가요?

좋아요. 세 번째 홉은 뭐죠?

3개예요.

그리고 붐, 붐, 붐.

오른쪽.

여기서 네 개를 얻고, 여기서 저것을 얻고, 마지막으로 다섯 개를 얻습니다.

우리는 실제로 그로부터 에코 응답을 받게 될 것입니다.

즉, 우리는 실제로 목적지를 찾았다는 뜻이죠?

그리고 그것이 전부였습니다.

그럼, 데모를 해볼까요?

클리어할 수 있을까?

어, 트레이스, 아티.

Windows에 Trace라는 프로그램이 있는 것 같아요.

Mac과 Linux에서는 Artie가 trace root를 호출합니다.

그러니 Google.com을 추적하여 근절하세요.

다른 것을 해 보자.

여기에 다른 네트워크가 있나요?

라우터를 추적하더라도 별 의미가 없습니다. 도움이 되는 방법이 하나뿐이거든요.

하지만 해보자.

정확히.

그럼 제 게이트웨이는 바로 그거 맞죠?

그러니까요.

그거요.

그건 무의미한 일이에요.

하지만 이 경로를 시도해 봅시다.

응, 다른 기계를 사용해 보자.

다른 기계가 있나요?

저는 그렇다고 생각해요.

좋습니다. 이렇게 해 봅시다.

바로 여기서 다른 맥북의 경로를 추적해 보겠습니다.

제 생각에는 254 대 10 정도일 거예요.

오른쪽.

그리고 곧바로 이 아름다움을 보세요.

그럼 여기로 traceroute를 하면 되는 거 맞죠?

우리는 바로 그 부분으로 넘어가겠습니다.

오른쪽?

우리가 실제로 라우터를 통과해야 하기 때문에 다른 홉은 없습니다.

라우터를 통해 내 패킷에 도달합니다.

하지만 여기 제 라우터는 스위치처럼 작동하죠?

스위치처럼 작동한다면, 모두 어느 계층 2로 연결되나요?

그래서 실제로는 세 번째 계층에는 도달하지 못합니다.

그래서 TTL이 없습니다.

동일한 네트워크로 무언가를 보내는 경우 TTL은 영향을 받지 않습니다.

이해하는 데 매우 중요합니다.

오른쪽.

매우, 매우, 매우 중요합니다.

뭔가 시도해 볼까요.

그리고 또 다른 네트워크.

나의 말이 들리니?

괜찮은.

구글 닷컴

물론이지요, 물론입니다.

이제 첫 번째 홉은 게이트웨이입니다.

왜냐하면 무슨 까닭일까?

142 252 72.142는 확실히 내 서브넷에 없습니다.

왜?

내 서브넷은 5개 중 25525개이므로 나가 아닙니다.

그래서 우리가 즉시 이 문제에 도달했을 때 아마도 나는 이 모든 것을 차단할 것입니다. 왜냐하면 이 모든 것이 내 것이기 때문입니다.

ISP에 이런 내용을 공개하고 싶지 않습니다.

오른쪽.

하지만.

여기에 아마 전부 다 나와 있을 거예요, 그렇죠?

이는 검색 결과가 Google에 도달할 때까지 거쳐온 모든 경로를 보여줍니다.

오른쪽.

그래서 보안상의 이유로 여기 일부를 차단하려고 합니다.

하지만 저는 이 내용의 일부를 차단하려고 합니다.

하지만 결국 우리는 Google 네트워크에 도달했다는 것을 여기서 볼 수 있습니다.

오른쪽.

괜찮은.

요약하면 어떨까요?

그렇다면 ICMP는 무엇일까요?

이는 정보를 주고받는 데 사용되는 IP 수준 프로토콜입니다.

매우 중요한 프로토콜이에요.

다행히도 일부 브라우저와 방화벽은 이를 차단합니다.

그리고 이것이 차단되면 ping을 보낼 수 없고, 중요한 정보 메시지를 보낼 수 없습니다.

이상한 상황에 처할 수도 있습니다.

ping과 추적 경로가 이를 사용하며, 모든 메시지를 조각화할 필요가 없습니다.

호스트에 접근할 수 있는지 없는지, 포트에 접근할 수 있는지 없는지 알려주는 데 사용됩니다.

알다시피, 그게 기본적으로 아주 중요한 인프라이고 기본적인 첫 번째 원칙 프로토콜이에요.

그것이 실제로 일어날 때 상황을 더 잘 설명할 수 있도록 그것을 이해해야 합니다.

아시다시피, 미래에는 우리가 이 ICMP 메시지를 확장할 수도 있을 겁니다.

우리에게는 도구가 너무 많아요. 알다시피, 흘릴 수도 있으니까요.

하지만 우리는 이걸 한 번도 사용하지 않습니다.

우리는 항상 다른 것 위에 무언가를 쌓아 올립니다.

ICMP를 우리 자신의 목적으로 사용할 수 있을지 궁금하네요.

괜찮은.

다음 강의로 넘어가겠습니다.