사이드카 패턴.
그래서 다시 한번, 저는 이것을 디자인 패턴 섹션에 추가하는 데 주저했습니다.
하지만 저는 이것이 정말 특별한 것은 아니라고 생각하지만 사이드카 패턴의 아키텍처는 정말 그렇습니다.
정말 나한테 말 걸어줘.
제 생각엔 마음에 들었고, 프로토콜을 사용할 때 발생하는 문제에 관한 것 같아요, 맞나요?
HTTP 프로토콜이나 SDB two, gRPC, Apache thread, SOAP, TCP 또는 일반 UDP를 사용하는 경우
프로토콜 언어를 구사하려면 프로토콜 언어를 구사해야 합니다.
사용하는 라이브러리는 특정 프로토콜 언어로 소켓에 쓰는 방법을 이해해야 합니다.
그리고 읽는 법을 이해해야 합니다.
그리고 정말 복잡해집니다.
프로토콜이 gRPC와 같이 복잡한 경우
그렇죠. HTTP를 사용하여 STB 2나 STB 1 또는 CB 3에 접속하면 클라이언트는 여기에서 격리됩니다.
HTTP 라이브러리는 변경되지 않습니다.
따라서 페치 요청이나 Axios를 보내는 경우 프로토콜이 어떻게 되어 있는지는 신경 쓰지 않아도 됩니다.
그들이 TB를 앞뒤로 만들 것이라고 말했기 때문에 그들은 배후에서 그것을 밝혔습니다.
어떤 언어를 사용하든 호환됩니다.
해당 요청을 다시 보내는 코드를 작성했다면 더 높은 수준의 쓰기 요청이 됩니다.
코드는 SDB 3에서 작동해야 하지 않나요?
최소한 JavaScript 관점에서 보면 이게 말이 되나요?
브라우저에서 사용되는 라이브러리는 HTTP 3과 SDB 2를 통신하는 방법을 이해합니다.
다르죠. 하나가 되어야 합니다. 확실히 지금까지와는 다릅니다.
그리고 이러한 라이브러리와 클라이언트는 정말 두꺼워지고 백엔드는 더욱 두꺼워집니다.
이 모든 복잡성을 가지고 있죠.
그래서 이 문제를 해결하기 위해 두 번째 패턴이 탄생했습니다.
그럼 여기서 몇 가지 예를 들어보겠습니다.
모든 프로토콜에는 라이브러리가 필요합니다.
이건 꼭 필요한 일이에요. SDB 하나라도요.
Python 앱이 있는 경우 호출을 하려면 HTTP 라이브러리를 가져와야 합니다.
당신은 글을 써야 합니다.
언어에 내장되어 있더라도 여전히 라이브러리입니다.
오른쪽?
마이크로소프트에는 라이브러리가 있고, C Sharp에는 라이브러리가 있으며, C++에는 풍부한 TV 라이브러리가 있습니다.
Python에는 많은 라이브러리가 있습니다.
그들은 당신에게 원하는 도서관 하나를 제공해야 합니다.
그렇다면 이 라이브러리는 보통 앱 내부에 있는 건가요?
그리고 여러분이 요청을 하면 그 요청은 여러분이 쓴 논리를 이해합니다.
get 요청을 하는 곳에서 get 슬래시를 쓰고 있는 거죠?
간단한 get 요청입니다.
이것은 The Wire에서는 완전히 다른 의미로 번역됩니다.
우리가 이야기한 것, 슬래시 프로토콜을 얻고 헤더가 이런 식으로 쓰여지고,
몸의 크기를 측정한 다음 이렇게 쓰고, 이렇게 요청을 마무리합니다.
그리고 그 모든 일을 다 하게 되는 거죠, 그렇죠?
컬(Curl)이 완벽한 예이다.
Curl은 클라이언트 라이브러리이며 특정 방식으로 TV를 올바르게 통신하는 방법을 알고 있습니다.
서버 측에서는 요청을 받고 싶어했습니다.
라이브러리가 작동하여 요청을 구문 분석한 다음 해당 요청을 애플리케이션으로 다시 이동합니다.
처리중.
SDB 2도 마찬가지입니다.
HTTP 2 라이브러리가 필요합니다.
오른쪽?
그래야 합니다.
귀하의 도서관에는 아마도 SDB와 one one이 둘 다 있을 것입니다.
따라서 SDB 두 클라이언트인 경우 "안녕하세요. 호출할 HTP를 만들고 싶습니다"라고 말하면 실제로 지정할 수 있습니다.
때때로 당신은 백엔드로서 여기서 애플리케이션 작성자로서 요청을 하지만
도서관은 STB를 지원하기로 결정할 수 있습니다. 즉, "저는 SDB 2를 수행할 것입니다."라고 말할 수 있습니다.
기본적으로 서버와 협상합니다.
그리고 어떤 프로토콜을 선택할 것인지 협상하는 방법은 또 다른 문제입니다.
그것도 그 자체로 또 다른 예술이에요.
따라서 클라이언트는 "안녕하세요, 저는 모든 TB에 XDR-TB를 제공합니다. 이는 귀하의 서버에 달려 있습니다."라고 말할 것입니다.
당신이 선택하면 서버가 선택해 줄 것입니다.
이것은 일반적으로 ALP라고 하는 TLS 확장을 통해 수행되며 이는 애플리케이션 계층 프로토콜입니다.
협상.
여러분, 이게 꽤 많은 정보라는 건 알지만, 저는 최소한으로만 설명하려고 노력합니다.
하지만 다시 한번, 팔의 속도로 코스를 따라가세요.
여기서는 서두를 일이 없습니다.
시간을 내어 많은 질문을 하면 서버는 "Hey, hey, let's, let's"라고 응답할 것입니다.
Edge TB 2와 대화한 다음, 완전히 다른 프로토콜인 약간의 대화를 시작합니다.
전선에 있는 것은 완전히 다른 것이어야 합니다.
모든 것이 스트리밍되고 마법의 스트림이 숫자를 스트리밍합니다.
매우 복잡한 것들이죠, 그렇죠?
그래서 모든 프로토콜에 필요한 라이브러리는 같은 내용을 알려줍니다.
암호화하는 방법.
TLS 클라이언트가 있을 수도 있죠?
TLS를 사용하는 HTTP https 요청을 한다고 가정해 보겠습니다.
TLS 라이브러리가 필요합니다.
따라서 해당 라이브러리는 TLS를 수행하기 위해 또 다른 라이브러리를 사용해야 합니다.
오른쪽.
그러면 여러분은 많은 라이브러리를 갖게 될 겁니다.
인기 있는 TLS 라이브러리 중 하나는 바로 개방형 SSL입니다. 제대로 알고 있다면 말이죠.
큰 누수가 발생했습니다.
그런 일이 일어났다는 게 믿기지 않습니다.
오른쪽.
그리고 이는 또 다른 문제입니다.
오른쪽?
자신이 모르는 것을 사용하면, 뭔가를 잃어버리면, 뭔가가 손상되면,
많은 사용자가 영향을 받을 것입니다.
제이를 찾아보세요.
무슨 일이에요?
오른쪽.
같은 것.
도서관.
도서관을 이용하세요.
당신은 도서관에 맡겨져 있습니다.
오른쪽?
그렇습니다. TLS 라이브러리를 사용하여 암호화할 수 있습니다.
오른쪽.
그리고 SSL을 열어 모든 암호화 작업과 암호화 정보를 처리합니다.
그러면 그걸 보내면 그걸 해독할 또 다른 테러리스트 도서관이 있을 거예요.
반드시 똑같은 녹일 필요는 없습니다.
Rust SSL이라고 불리는 것을 사용할 수 있고, 서버는 그것을 사용하여 이해할 수 있습니다.
TLS는 프로토콜이잖아요?
그 라이브러리를 만든 사람은 프로토콜 의미론을 준수해야 하며 그렇지 않아야 합니다.
호환성 문제가 발생합니다.
그리고 같은 일이 반복되었습니다.
gRPC를 사용하려면 gRPC 라이브러리를 작성해야 하고 양쪽에 PC 라이브러리가 있어야 합니다.
이것은 양식입니다.
보통은 이런 식입니다.
ID는 기본적으로 gRPC를 구축했습니다.
여러분은 각 언어에 대한 라이브러리를 구축한 다음 이를 활용할 수 있습니다.
gRPC가 효과적으로 작동하는 방식이 바로 이것입니다.
그것도 보여드리겠습니다.
그래서 라이브러리를 바꾸는 건 어려워지죠.
그런 일이 일어났어요.
J 오른쪽을 찾으세요.
무슨 일이에요?
특히 SSL 업데이트에 문제가 있는 경우, 특히 SSL이 정말 단단히 고정되어 있는 경우,
당신이 떠나면 앱이 굳어버리잖아요, 그렇죠?
앱과 라이브러리는 동일한 언어여야 합니다.
그건 또 다른 문제예요.
올바른 언어가 있다면 반드시 사용해야 하는 Python 앱을 작성하는 것입니다.
실제로는 그렇지 않지만 대부분의 경우 Python 패키지가 있는 라이브러리를 사용해야 합니다.
나를 봤지?
저는 Node.js로 웹 소켓 애플리케이션을 작성했습니다.
저는 Node.js 웹 소켓 패키지를 사용했습니다.
오른쪽.
같은 언어여야 하지 않나요?
반드시 그럴 필요는 없습니다.
C API로 장난칠 수 있다.
상호 운용성 조정 및 그런 것들을 수행하세요.
하지만 대부분의 경우 앱과 이를 가져오기 위한 라이브러리는 동일한 언어, 동일한 프로그래밍이어야 합니다.
언어.
자바, 자바, C 숍.
괜찮은.
그런 상황을 피할 수 있는 방법이 있지만, 이는 이 강좌의 범위를 벗어납니다.
따라서 이미 필요한 것을 변경하면 라이브러리를 다른 라이브러리로 변경하는 경우 반환됩니다.
그래서 같은 언어여야 한다는 제한이 있습니다.
그리고 재테스트가 필요한 또 다른 한계도 있습니다.
재시험은 힘들죠?
홈 호환성에 대한 중요한 변경 사항.
제가 해야 할 모든 일은 라이브러리 아트에 기능을 추가하는 것과 그 결과 마이크로서비스입니다.
시달리다.
이것이 마이크로서비스가 인기를 얻은 한 가지 이유입니다.
그것은 그들이 해결하려고 노력했던 문제 중 하나였습니다.
제 생각에 트위터가 이 모든 것을 시작한 건 2010년이었던 것 같습니다.
어디.
저는 2010 월드컵을 믿습니다.
우리는 트윗을 하고 있었습니다.
나는 "그래, 그러면 트위터가 사라질 거야"라고 생각했습니다.
재밌는 건, 폴이 2010년경에 그녀에게 정말, 정말 인기가 있었다고 말했을 때,
오른쪽?
그리고 그들은 돌아와서 월드컵에서 부담을 감당하지 않을 것입니다. 왜냐하면 모두가 트윗을 했기 때문입니다.
동시에.
그것은 단지 VM이었습니다.
그들은 VM을 가지고 있습니다.
그리고 이 내용도 트위터 직원 중 한 명이 팟캐스트에서 발췌한 것입니다.
이건 제가 지어낸 얘기가 아니에요.
저는 트위터에서 일하지 않았습니다.
그런데 VM이 갑자기 충돌하고 꺼져 버리는 거예요.
그래서 그들은 판매를 해야 했고, 그런 다음 로드 밸런싱을 수행하기 위해 또 다른 VM을 구동할 시간도 필요했습니다.
시간이 많이 걸리고 VM 없이는 작동이 중단될 것입니다.
그래서 그들은 모놀리스 VM에서 마이크로서비스로 전환했습니다.
그들은 트윗 API만 깨고, Red API도 깨고, 다른 API도 깨고 다 깨졌어요.
그들은 이를 많은 서비스로 나누었고, 그러다가 서로 소통할 필요가 있다는 것을 깨달았습니다.
그래서 그들은 핀 앵글이라는 이름의 자신들만의 도서관을 세웠습니다.
그리고 그 라이브러리는 기본적으로 이러한 마이크로서비스와 통신하는 데 사용됩니다.
이 도서관은 기본적으로 그렇습니다.
모든 사람이 이 도서관을 이용해야 하며, 어떤 언어든 사용하도록 강요받습니다.
무슨 언어인지는 기억이 나지 않지만, 해당 언어로 고정되어 있습니다.
그리고 그런 시스템을 만든다면, 당신은 그 시스템에 갇히게 될 것이고, 그게 괜찮습니다.
효과가 있으면 효과가 있는 거죠.
트위터는 효과가 있는 것 같죠?
여기서 활용할 수 있는 요령이 있습니다.
의사소통이라는 아이디어를 다른 사람에게 위임한다면 어떨까요?
앱.
그러면 우리 대신 프록시가 통신하도록 하면 어떨까요?
오른쪽.
그럼 프록시에는 풍부한 라이브러리가 있나요?
그리고 클라이언트의 라이브러리는 매우 빈약합니다.
그것은 프록시와 통신합니다.
하나가 되는 것은 결코 변하지 않는 것이며 하나가 되는 것은 결코 변하지 않는 것이며 그것은 아름답고 우아한 디자인입니다.
결코 변하지 않습니다.
그래서 우리는 하나의 프록시 이니셔티브를 살펴볼 수 있고 프록시는 어떤 언어나 다른 언어로든 자유롭게 통신할 수 있습니다.
그런데 실제 최종 목적지에 대한 백엔드에 어떤 프로토콜을 선택하든,
또 다른 프록시.
오른쪽.
바로 여기에 요령이 있습니다.
사이드카 패턴을 만나보세요.
따라서 이 경우 각 클라이언트는 사이드카 프록시를 가져야 합니다.
오른쪽.
여기에 간단한 예가 있습니다. 여기에 STB 1개와 클라이언트 1개가 있다고 가정해 보겠습니다.
하나의 서버가 되는 게 맞죠?
그래서 우리가 하는 일은 내 애플리케이션에서 프록시를 구성하여 모든 HTTP 요청이
이 사이드카 프록시로 안내해 주세요.
그리고 이 기능을 사이드카(Sidecar)라고 부르는데, 문자 그대로 동일한 기계 내부에 들어있기 때문입니다.
그러니까 이게 루프백이에요.
이것도 루프백이 될 수 있어요.
두 가지 응용 프로그램.
마치 동일한 서버, 동일한 컴퓨터에서 실행되는 다른 애플리케이션과 같습니다.
예를 들어 Fiddler와 Charlie, 그리고 중간 프록시의 디버깅 담당자가 일하는 방식이 그렇습니다.
오른쪽?
문자 그대로 프록시를 시작하고 모든 안정적인 요청이 프록시를 통과하도록 하면 됩니다.
효과적으로 기록할 수 있나요?
프록시는 이런 식으로 작동해요.
그리고 이거요.
그러니까 마지막 요청은 사실 당신이 이 남자에게 가는 거 맞죠?
여기가 최종 목적지입니다.
하지만 기본적으로 프록시를 모두 구성했기 때문에 모든 요청이 이 사람에게 전송됩니다.
이 사람에게 갈게요.
따라서 요청을 보내면 사이드 카드 프록시가 해당 요청을 수신하고 최종 결과를 알게 됩니다.
호스트 헤더에서 목적지를 찾습니다.
그런 헤더가 있는 헤더 특정 헤더가 있고 그런 다음 해당 작업을 수행하고 "안녕하세요, 당신이니까"라고 말합니다.
여전히 하나에만 있는 경우 실제 서버 측 역방향 프록시와 어떻게 통신하는지 신경 쓰지 않습니다.
오른쪽?
당신이 하는 일은 '헤이'입니다.
1인치 TV도 만들 거예요.
보안 연결을 사용하려고 합니다.
최신 도구 라이브러리 1.3을 사용할 겁니다.
재즈 음악이죠.
그리고 저는 그 요청을 정리하고 있어요.
그리고 서버 측에서는 색상 프록시가 수신합니다.
그것은 단지 누군가가 나에게 말을 걸면 이것이 실제 서버라는 것을 알고 있다는 것입니다.
나는 이야기하고 싶습니다.
그리고 이것도 역시 같은 기계에 들어있습니다.
반드시 그럴 필요는 없지만 대부분은 그렇습니다.
이것이 컨테이너 아키텍처에서 사이드카 컨테이너 또는 이와 유사한 것으로 불리는 곳인 경우입니다.
기본적으로 호스트와 애플리케이션의 루프백을 공유합니다.
바로 그것이 요령이에요.
다시 말해서, 그럴 필요는 없습니다. 다른 컨테이너를 넣을 수도 있고 다른 IP 주소를 넣을 수도 있습니다.
그리고 이를 구성합니다.
루프백은 IP 주소가 변경되는 것보다 변경되지 않기 때문에 루프백을 사용하는 것이 더 쉽습니다.
그리고 위협도 있습니다.
그래서 당신이 한 일은 요청을 보냈지만 두 번의 홉을 거쳤고 통신이 완전히 완료되었다는 것입니다.
당신에게서 고립됨.
앱은 변경되지 않습니다.
이 경우에는 최종 목적지에 대한 요청을 할 수 있는 요청을 계속 하고 있습니다.
하지만 갑자기 프록시를 넣었으니까 작동하는 거 아니겠어요?
클라이언트 측 프록시는 모든 것을 포착하고 변경하게 됩니다.
요청사항을 다시 작성하세요.
그래서 클라이언트 측 프록시는 실제로 모든 것을 보고 이 사람도 모든 것을 봅니다.
그러니 당연히 이 사람들을 믿어야겠죠.
그래서 우리는 새로운 프로토콜을 얻었습니다.
실제로 아무것도 업그레이드할 필요가 없습니다.
그러니까 이걸 소유한 사람이 업그레이드를 할 거예요.
이는 일반적으로 서비스 메시의 서비스 메시가 사이드카 패턴을 기반으로 하는 방식입니다.
심볼, 예를 들어 Envoy나 Link 또는 D와 같이 이러한 프록시가 서로 통신하고 모든 작업을 수행하는 곳을 알 수 있습니다.
즉, 서버가 실제로 응답하면 전화를 건 사람에게 다시 응답하게 됩니다.
그리고 서버에 전화를 건 사람이 실제로 프록시 맞나요?
그래서 그냥 다시 응답할 뿐이에요.
오른쪽.
그리고 그것은 단지 또 다른 클라이언트 서버 요청 응답 시스템일 뿐이죠?
응답을 한 후 이를 사용합니다.
그리고 우리가 응답하기 때문에 여기 역방향 프록시는 그것을 가져와서 다시 쓸 것입니다.
올바른 응답을 만들어내고 요청을 만들어낸 것과 동일한 연결입니다.
그리고 그걸 얻으면 이 경우 서버는 자동으로 뒤로 물러납니다.
그래서 모두가 효과적으로 이것을 기다리고 있었고, 우리가 응답을 받을 때까지 요청을 했습니다.
우리가 돌아올 때까지 대리인이 이 모든 일을 했습니다.
매우 우아해요.
다른 사람에게 책임을 떠넘기는 시대가 정말 좋아요.
멋진.
안녕하세요, 저는 TB 3에 대해 이야기하고 싶습니다.
쉬운.
아무것도 바꿀 필요가 없습니다.
코드는 동일하게 유지됩니다.
여기 역 프록시, 이러한 측면 패턴은 업그레이드해야 하며, 그들이 업그레이드하는 유일한 것입니다.
그리고 그들은 우리를 그렇게 팔았습니다.
그렇죠.
마이크로서비스와 서비스 메시에 대해서요.
서비스 아키텍처는 "안녕, Link RD 1.3으로 업그레이드하면 갑자기 HDB 3이 생깁니다"라고 말합니다.
안전하고 빠른 프로토콜을 얻을 수 있습니다.
이것만 업그레이드하면 얼마나 멋진지, 여기 저기서 연결만 제거하면 되는군요.
여기서도 마찬가지다.
그러면 사이드카 패턴의 예, 서비스 메시 프록시에 대해 알아보겠습니다.
우리가 Ray Link 또는 Istio에 대해 이야기했듯이, Google One Envoy는 프록시 컨테이너입니다.
네, 앞서 말했듯이 원형 프록시를 그 자체로 컨테이너로 만들 수 있습니다.
하지만 중요한 건, 7번째 레이어여야 한다는 거죠.
그리고 우리는 7층과 4층의 차이점에 대해 이야기해 보겠습니다.
이건 매우 중요한 일이에요.
그리고 프로토콜 섹션에서는 7계층 로드 밸런싱의 7계층 프록시에 대해 이야기해 보겠습니다.
7번째 레이어는 무엇입니까?
4번째 레이어는 무엇입니까?
왜냐하면 이건 여러분이 알아야 하고, 이해해야 하는 일이기 때문입니다.
제 생각에 OSI 모델은 백엔드 엔지니어링과 관련해 가장 중요한 것 중 하나입니다.
적어도.
오른쪽.
그러니까 7번째 레이어여야 해요.
제 말은, 모든 것을 해독하고 모든 것을 보고 다시 복구하는 응용 프로그램이라는 뜻이에요.
백엔드에서 암호화하고 기본적으로는 애플리케이션입니다.
그렇다면 장단점은 무엇일까요?
장점은 언어에 구애받지 않는다는 점입니다.
이를 폴리글롯 아키텍처라고 부릅니다.
오른쪽.
이 경우, 두 가지 서비스를 강제로 라이브러리를 사용하도록 하는 경우 모든 사람이
같은 언어를 사용해야 하는 이유는 라이브러리가 무엇이든 같은 언어여야 하기 때문이 아닌가요?
각도에 따른 트위터, 그 언어가 뭐든 괜찮을 것 같아요.
Java 또는 Scala는 무엇인가요?
스칼라는 스칼라였던 것 같아요.
오른쪽.
그렇죠. 모두가 Scala로 작성해야 하죠.
다 그거죠.
다른 언어로 글을 쓸 수 없어요. 무슨 일이 일어날까요?
네트워킹 요청을 하기 위해 연결을 만들고 이 모든 재시도 논리를 수행하고 이 모든 아름다운 회로를 만들려면
이 모든 특별한 논리를 깨는 건, 단순히 프로토콜을 만드는 게 아니잖아요, 그렇죠?
이 사이클 프록시에서 모든 특수 네트워킹 로직, 네트워킹 관련 모든 것, 모든 것을 수행할 수 있습니다.
연결과 관련된 모든 요청과 재시도가 그곳에서 이루어질 수 있습니다.
하지만 라이브러리에 갇히게 되면 언어에 갇히게 되는 게 아닌가?
하지만 이 경우에는 당신의 언어입니다.
JavaScript와 통신하는 Python 마이크로서비스를 빌드할 수 있습니다.
마이크로서비스 이유는 중요하지 않다?
사이드카 프록시가 내장되어 있기 때문에, 예를 들어 Rust Write Linker라고 하면, Curly는 Rust를 사용하고 이것이 이것입니다.
남자들이 서로 이야기합니다.
나는 상관하지 않아.
어쨌든 프록시 간 연결에는 HTTP를 사용할 거죠?
그러니 언어에 구애받지 않습니다.
프로토콜이 업그레이드됩니다.
보안을 확보하면, 아무리 보안이 취약하더라도 처형당할 수 있습니다.
그리고 만약 TLS 라이브러리 중 하나가 약한 암호를 가지고 있는 것으로 밝혀진다면 프록시를 구성하세요.
더 이상 암호를 사용하면 안 됩니다.
그리고 모든 애플리케이션에 최신 변경 사항이 적용됩니다.
꽤 멋진 추적 및 모니터링이 가능하므로 이제 모든 것이 이것과 동일하게 진행되므로 요청을 추적할 수 있습니다.
깔때기 모양이죠?
그리고 이것은 핵심 프록시가 서로 통신하고 제어 평면이라고 하는 것을 가지고 있다고 말합니다.
거의 모든 것을 제어하는 중앙 집중식 기능이 있어서 추적이 가능합니다.
모니터를 제어할 수 있습니다. 오, 이 서비스는 실제로 이 서비스와 통신할 수 없습니다.
이 서비스는 서비스와 통신할 수 있습니다.
오른쪽.
그리고 특별한 추적 ID로 태그 요청을 추가하여 추적 요청을 모니터링할 수 있습니다.
마이크로서비스의 전체 아키텍처에서 이를 따를 수 있습니다.
따라서 서비스 8이 서비스 B와 대화하고 B가 C와 대화하고 C가 D와 대화하고 D가 귀하, E 및 D와 대화한다면
E가 F에게 말을 걸고, 당신은 한 가지 요청을 보내 추적에 얼마나 걸리는지 알고 싶어합니다.
서비스 메시를 사용 중이든, 서비스를 사용하지 않든, 잊어버리세요.
이것을 올바르게 추적하세요.
추적 ID가 무엇인지 이해하려면 모든 서비스에 이를 알려야 합니다.
하지만 그렇지 않고 신경 쓰지 않는다면 사이드카 패턴으로 서비스를 사용하는 것이 핵심 패턴입니다.
추적 ID를 추가하면 요청을 계속 추적하여 추적합니다.
해당 추적 ID를 반복하세요.
서비스 발견.
오른쪽.
서비스를 발견할 수 있는 또 다른 곳이죠.
중앙 집중식 DNS 시스템을 사용하고 이 모든 것을 수행합니다.
프록시는 서비스 검색과 통신합니다.
더 이상 생각할 필요도 없습니다.
이 사이드카 패턴을 캐싱하면 다시 캐싱을 수행할 수 있습니다.
오른쪽?
매우 흥미로운 사실이죠.
오른쪽.
비록 이것이 모두 해야 할 일들이지만요.
하지만 물론, 그것은 복잡합니다.
무료인 것은 없죠?
난 내가 끝났다는 걸 알아.
저는 제가 프로라고 생각해요.
괜찮은.
이제 콘입니다.
뭐가 나쁜데?
복잡성.
우리는 방금 그것에 대해 이야기했습니다.
그것은 복잡한 시스템이며 복잡성은 모든 것을 이해하는 것이 매우 효과적으로 어렵다는 것을 의미합니다.
이게 뭐야, 물건이 망가졌는지 알기가 힘들어.
오른쪽.
이걸 어떻게 디버깅하나요?
마이크로서비스 디버깅은 행운을 빕니다.
숨어 있음.
존재하지 않는 홉 두 개를 추가한 건가요?
각 호출에서 프록시에 한 홉을 추가하고 역방향 프록시에 한 홉을 추가하면 다시 다음으로 돌아갑니다.
서버.
이러한 홉은 지역적이기는 하지만 요청을 다시 작성하는 데 비용이 들고 이해해야 합니다.
요청을 하고 프로토콜을 업그레이드합니다.
그 모든 일을 하고 있어요.
추적 수행, 서비스 검색, 캐싱 수행, 추적 수행 등 모든 작업이 여기에 있습니다.
모든 것의 비용을 말하고 나서 사이드카 프록시 강의는 끝납니다.
그리고 이것이 이 섹션에 대한 마지막 강의라고 생각합니다.
물론, 언제나 그렇듯이 앞으로 더 많은 강의를 추가할 수도 있지만 이 강의를 녹음한 시점으로는
이것은 이 섹션의 마지막 강의입니다.
다음 시간에는 프로토콜 섹션에서 뵙겠습니다.
그동안, 수업을 즐기세요.
